[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Olá! Sou Lucas da Silva, graduando em Ciências Contábeis pela Universidade Federal da Paraíba.\nDurante minha formação estudantil, fui selecionado pelo programa de intercâmbio estadual Gira Mundo, onde tive a oportunidade de estudar em Ontário, Canadá, por seis meses. Ao retornar ao Brasil, fui contemplado com uma bolsa de estudos no CCAA, onde concluí o curso de inglês e, posteriormente, atuei como professor de língua inglesa.\nAo longo da minha graduação, fui pesquisador bolsista e participei de diversos programas de extensão, nos quais desenvolvi habilidades com a linguagem de programação R e seus diversos pacotes, como o Tidyverse, além de seus frameworks, como Shiny e Quarto. Essas experiências me proporcionaram uma base sólida em Data Science, em Estatística e em Finanças e, eventualmente, influenciaram meus interesses em outras ferramentas, como PowerBI, Python e SQL, e em algumas áreas de atuação profissional, como Auditoria, Forensics e FP&A.\nFora do ambiente acadêmico e profissional gosto de acompanhar esportes, de experimentar diferentes distribuições linux e de jogos de bloquinhos quadrados."
  },
  {
    "objectID": "index.html#formação",
    "href": "index.html#formação",
    "title": "Lucas da Silva",
    "section": "Formação",
    "text": "Formação\n\nUniversidade Federal da Paraíba | Graduação em Ciências Contábeis | Desde 2020\nEscola de Idiomas CCAA | Curso de Língua Inglesa | Jul 2019 - Ago 2020\nWalkerton District Community School | Intercâmbio | Set 2018 - Fev 2019"
  },
  {
    "objectID": "proj1.html",
    "href": "proj1.html",
    "title": "Test 1",
    "section": "",
    "text": "This is a test."
  },
  {
    "objectID": "blog/blogpost1.html",
    "href": "blog/blogpost1.html",
    "title": "Blog Template",
    "section": "",
    "text": "This is the first post in my blog!\nNote that all blog posts are frozen, i.e., when we render the entire site the computations are not re-run, but rather read from the previously frozen results\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/blogpost1.html#subsection-header",
    "href": "blog/blogpost1.html#subsection-header",
    "title": "Blog Template",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Blog Template\n\n\n\n\n\nThis is a blog template\n\n\n\n\n\n20 de jan. de 2023\n\n\nLucas\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Limpando dados com {janitor}\n\n\nFerramentas poderosas para facilitar a hora da faxina.\n\n\n\n\n\n\n12 de nov. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransformando dados com across( )\n\n\nFazendo mais com menos.\n\n\n\n\n\n\n8 de out. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGerenciando dependências com {renv}\n\n\nGarantindo a reprodutibilidade do seu código de maneira simples.\n\n\n\n\n\n\n19 de set. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIniciando no R: instalação do R e Rstudio\n\n\nSetup do ambiente para ciência de dados.\n\n\n\n\n\n\n26 de ago. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlanilhas do Excel no R\n\n\nDados do Excel ao R de maneira fácil e rápida.\n\n\n\n\n\n\n7 de ago. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUma breve introdução ao Tidyverse\n\n\nUm resumo do essencial para iniciar no mundo do Tidyverse.\n\n\n\n\n\n\n5 de ago. de 2024\n\n\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "blog/blogposts/blogpost1.html",
    "href": "blog/blogposts/blogpost1.html",
    "title": "Blog Template",
    "section": "",
    "text": "This is the first post in my blog!\nNote that all blog posts are frozen, i.e., when we render the entire site the computations are not re-run, but rather read from the previously frozen results\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/blogposts/blogpost1.html#subsection-header",
    "href": "blog/blogposts/blogpost1.html#subsection-header",
    "title": "Blog Template",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog/blogposts/test/index.html",
    "href": "blog/blogposts/test/index.html",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "",
    "text": "O tidyverse, uma coleção de pacotes focados em ciência de dados, é um dos principais atrativos da linguagem de programação R. Nesta postagem serão sintetizados os principais aspectos necessários para o início da jornada na ciência de dados com o tidyverse."
  },
  {
    "objectID": "blog/blogposts/test/index.html#subsection-header",
    "href": "blog/blogposts/test/index.html#subsection-header",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog/blogposts/test/index.html#ler-e-escrever-dados",
    "href": "blog/blogposts/test/index.html#ler-e-escrever-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Ler e escrever dados",
    "text": "Ler e escrever dados\nO pacote readr facilita escrever ou ler os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, vamos importar dados de mobilidade registrados pela Google durante a pandemia de COVID-19.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv( ) ou read_csv2( )\nimporta dados csv (vírgula ou ponto e vírgula)\n\n\nread_delim( )\nseparador geral\n\n\nread_table( )\nseparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\ngoogle_mobility &lt;- read_csv(\"Global_Mobility_Report.csv\")\n\nRows: 516697 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (6): country_region_code, country_region, sub_region_1, sub_region_2, i...\ndbl  (6): retail_and_recreation_percent_change_from_baseline, grocery_and_ph...\ndate (1): date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ngoogle_mobility\n\n# A tibble: 516,697 × 13\n   country_region_code country_region  sub_region_1 sub_region_2 iso_3166_2_code\n   &lt;chr&gt;               &lt;chr&gt;           &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;          \n 1 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 2 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 3 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 4 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 5 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 6 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 7 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 8 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 9 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n10 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n# ℹ 516,687 more rows\n# ℹ 8 more variables: census_fips_code &lt;chr&gt;, date &lt;date&gt;,\n#   retail_and_recreation_percent_change_from_baseline &lt;dbl&gt;,\n#   grocery_and_pharmacy_percent_change_from_baseline &lt;dbl&gt;,\n#   parks_percent_change_from_baseline &lt;dbl&gt;,\n#   transit_stations_percent_change_from_baseline &lt;dbl&gt;,\n#   workplaces_percent_change_from_baseline &lt;dbl&gt;, …\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#transformação-de-caracteres",
    "href": "blog/blogposts/test/index.html#transformação-de-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de caracteres",
    "text": "Transformação de caracteres\nPara trabalhar com caracteres (a.k.a. strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nstr_replace\nSubstitui padrões\n\n\nstr_c\nCombine caracteres\n\n\nstr_detect\nDetecta padrões\n\n\nstr_extract\nExtrai padrões\n\n\nstr_sub\nExtrai por posição\n\n\nstr_length\nTamanho de uma string\n\n\n\nÉ comum o uso de expressões regulares para detecção de padrões. Mais detalhes sobre as funções e expressões regulares podem ser entrontados cheat-sheet do stringr.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\n\n# substituir 'er' com espaço vazio\nstr_replace(month.name, \"ber$\", \"\")\n\n [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"   \n\n\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n\n [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n[11] \"November_11\" \"December_12\"\n\n\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n\n[1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n\n\n# detectar padrão\nstr_detect(month.name, \"^A\")\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n# extrair padrão\nstr_extract(month.name, \"ber$\")\n\n [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, 1, 2)\n\n [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n\n\n# tamanho da string de cada mês\nstr_length(month.name)\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8"
  },
  {
    "objectID": "blog/blogposts/test/index.html#gerenciamento-de-dados-e-horas",
    "href": "blog/blogposts/test/index.html#gerenciamento-de-dados-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de dados e horas",
    "text": "Gerenciamento de dados e horas"
  },
  {
    "objectID": "blog/blogposts/test/index.html#gerenciamento-de-datas-e-horas",
    "href": "blog/blogposts/test/index.html#gerenciamento-de-datas-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de datas e horas",
    "text": "Gerenciamento de datas e horas\nO pacote lubridate é excelente para lidar com datas e horas. Apenas devemos conhecer as seguintes abreviações:\n\nymd signfica y:year (ano), m:month (mês), d:day (dia)\nhms signfica h:hour (hora), m:minutes (minutos), s:seconds (segundos)\n\n\n# vetor com datas\ndatas &lt;- c(\"2020/12/31\", \"2012/05/04\", \"2003/09/24\",\"2017/11/24\")\n\n# vetor com datas e horas\ndatas_horas &lt;- c(\"1973-08-11 02:00\", \"2009-06-13 20:00\")\n\ndatas &lt;- ymd(datas)\ndatas\n\n[1] \"2020-12-31\" \"2012-05-04\" \"2003-09-24\" \"2017-11-24\"\n\n\n\ndmy(\"13-08-2002\")\n\n[1] \"2002-08-13\"\n\nymd(\"20020813\")\n\n[1] \"2002-08-13\"\n\n\n\n# extrair o ano\nyear(datas)\n\n[1] 2020 2012 2003 2017\n\n\n\n# extrair o mês\nmonth(datas)\n\n[1] 12  5  9 11\n\n\n\n# extrair o dia da semana\nwday(datas)\n\n[1] 5 6 4 6\n\n\n\n# extrair a hora\nhour(datas_horas)\n\n[1]  2 20\n\n\n\n# adiciona 10 dias\ndatas + days(10)\n\n[1] \"2021-01-10\" \"2012-05-14\" \"2003-10-04\" \"2017-12-04\"\n\n\n\n# adiciona 1 mês\ndatas + month(1)\n\n[1] \"2021-01-01\" \"2012-05-05\" \"2003-09-25\" \"2017-11-25\"\n\n\nPara mais detalhes, veja o cheat-sheet do lubridate."
  },
  {
    "objectID": "blog/blogposts/test/index.html#importar-e-salvar-dados",
    "href": "blog/blogposts/test/index.html#importar-e-salvar-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importar e salvar dados",
    "text": "Importar e salvar dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos os dados Palmer Penguins, dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv() ou read_csv2( )\nImporta .CSV (vírgula ou ponto e vírgula)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# Assinala o arquivo penguins.csv, que está na pasta \"data\", ao objeto \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Inspeciona o conteúdo do objeto \"penguins\"\npenguins\n\n# A tibble: 344 × 9\n   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1     1 Adelie  Torgersen           39.1          18.7               181\n 2     2 Adelie  Torgersen           39.5          17.4               186\n 3     3 Adelie  Torgersen           40.3          18                 195\n 4     4 Adelie  Torgersen           NA            NA                  NA\n 5     5 Adelie  Torgersen           36.7          19.3               193\n 6     6 Adelie  Torgersen           39.3          20.6               190\n 7     7 Adelie  Torgersen           38.9          17.8               181\n 8     8 Adelie  Torgersen           39.2          19.6               195\n 9     9 Adelie  Torgersen           34.1          18.1               193\n10    10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#trabalhando-com-caracteres",
    "href": "blog/blogposts/test/index.html#trabalhando-com-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Trabalhando com caracteres",
    "text": "Trabalhando com caracteres\nPara trabalhar com caracteres (strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\n\nFunção\nDescrição\n\n\n\n\nstr_replace()\nSubstitui padrões\n\n\nstr_c()\nCombina caracteres\n\n\nstr_detect()\nDetecta padrões\n\n\nstr_extract()\nExtrai padrões\n\n\nstr_sub()\nExtrai por posição\n\n\nstr_length()\nRetorna o tamanho de uma string\n\n\n\nÉ comum o uso de expressões regulares (regex) para detecção de padrões. Abaixo temos alguns exemplos de funções do stringr em ação em conjunto com o uso de regex.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\n\n# substituir 'er' com espaço vazio\nstr_replace(month.name, \"ber$\", \"\")\n\n [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"   \n\n\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n\n [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n[11] \"November_11\" \"December_12\"\n\n\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n\n[1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n\n\n# detectar padrão\nstr_detect(month.name, \"^A\")\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n# extrair padrão\nstr_extract(month.name, \"ber$\")\n\n [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, 1, 2)\n\n [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n\n\n# tamanho da string de cada mês\nstr_length(month.name)\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8\n\n\nMais detalhes sobre as funções e expressões regulares podem ser encontrados no cheat-sheet do stringr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#transformação-de-tabelas",
    "href": "blog/blogposts/test/index.html#transformação-de-tabelas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de tabelas",
    "text": "Transformação de tabelas\nOs pacotes dplyr e tidyr oferecem gramática para a transformação de dados, ou seja, um conjunto de verbos úteis para resolver problemas. As funções mais importantes são:\n\n\n\nFunção\nDescrição\n\n\n\n\nmutate()\nAdiciona ou modifica variáveis\n\n\nselect()\nSeleciona variábeis\n\n\nfilter()\nAplica filtro\n\n\nsummarise()\nReduz variáveis\n\n\nrename()\nRenomeia colunaas\n\n\n\n\nselect() e rename()\nConseguimos selecionar ou remover colunas com a função select(), usando o nome ou índice da coluna. Para deletar colunas apenas usamos o ponto de exclamação antes do nome ou índice da coluna. A função rename()renomeia colunas da mesma forma, usando o nome ou índice da coluna.\n\n# Assinala o resultado da cadeia ao objeto \"penguins_2\" \npenguins_2 &lt;- penguins |&gt; \n    # Seleciona a coluna \"rowid\".\n    # O ponto de exclamação indica a remoção da coluna \"rowid\"\n    select(!rowid) |&gt; \n    # Renomeia a coluna \"species\" como \"penguin_species\"\n    rename(penguin_species = species)\n\n# Visualizando o novo objeto\npenguins_2\n\n# A tibble: 344 × 8\n   penguin_species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Torgersen           39.1          18.7               181\n 2 Adelie          Torgersen           39.5          17.4               186\n 3 Adelie          Torgersen           40.3          18                 195\n 4 Adelie          Torgersen           NA            NA                  NA\n 5 Adelie          Torgersen           36.7          19.3               193\n 6 Adelie          Torgersen           39.3          20.6               190\n 7 Adelie          Torgersen           38.9          17.8               181\n 8 Adelie          Torgersen           39.2          19.6               195\n 9 Adelie          Torgersen           34.1          18.1               193\n10 Adelie          Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nfilter()e sort()\nPara filtrar dados, usamos o verbo filter() com operadores lógicos (&gt;, ==, etc.) ou funções retornando em valores lógicos (str_detect(), is.na()). A função arrange() classifica os valores de menor para maior ou classifica múltiplas variáveis.\n\npenguins_2 |&gt;\n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Dream\"\n    filter(island == \"Dream\") |&gt; \n    # Classifica os dados pela coluna \"year\"\n    arrange(year)\n\n# A tibble: 124 × 8\n   penguin_species island bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Dream            39.5          16.7               178\n 2 Adelie          Dream            37.2          18.1               178\n 3 Adelie          Dream            39.5          17.8               188\n 4 Adelie          Dream            40.9          18.9               184\n 5 Adelie          Dream            36.4          17                 195\n 6 Adelie          Dream            39.2          21.1               196\n 7 Adelie          Dream            38.8          20                 190\n 8 Adelie          Dream            42.2          18.5               180\n 9 Adelie          Dream            37.6          19.3               181\n10 Adelie          Dream            39.8          19.1               184\n# ℹ 114 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nsummarise()\nComo encontramos a média do tamanho dos bicos dos pinguins na ilha de Biscoe, por espécie de pinguim?\nPara encontrarmos a resposta, devemos filtrar os dados pela ilha Biscoe e então agrupar por espécies. Quando usamos a função summarise(), podemos agrupar os dados para executarmos a redução dos dados.\n\npenguins_2 |&gt; \n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Biscoe\"\n    filter(island == \"Biscoe\") |&gt; \n    # Cálculo da média da coluna \"bill_length_mm\" através da função mean()\n    # O resultado do cálculo será assinalado a nova coluna \"bill_length_mm_mean\"\n    # O segundo parâmetro (na.rm = TRUE) remove os dados não identificados (NAs)\n    # O cálculo é aplicado ao agrupamento de cada espécie, na coluna \"penguin_species\"\n    summarise(\n        bill_length_mm_mean = mean(bill_length_mm, na.rm = TRUE),\n        .by = penguin_species\n    ) |&gt; \n    # Classifica a tabela resultante pelo tamanho do bico\n    arrange(bill_length_mm_mean)\n\n# A tibble: 2 × 2\n  penguin_species bill_length_mm_mean\n  &lt;chr&gt;                         &lt;dbl&gt;\n1 Adelie                         39.0\n2 Gentoo                         47.5\n\n\n\n\nTabelas longas ou largas\nÉ muito comum modificar tabelas nos dois formatos: longas ou largas. Tabelas longas são mais comuns para trabalhar dados, porém muitas vezes os dados que se tem em mãos são estruturados em tabelas largas ou em algumas ocasiões tabelas longas são desejadas.\n\n# Tabela larga\ntidyr::table4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n# Tabela larga para tabela longa\ntable4a_long &lt;- tidyr::table4a |&gt; \n    pivot_longer(\n        cols = !country,\n        names_to = \"year\",\n        values_to = \"cases\"\n    )\n\n# Tabela longa\ntable4a_long\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n# Tabela longa para tabela larga novamente\ntable4a_long |&gt; \n    pivot_wider(\n        names_from = year,\n        values_from = cases\n    )\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nDe fato, o uso de tabelas longas dá origem ao termo tabelas tidy, o modelo de estruturação de dados ideal para data science, e que eventualmente nomeia o tidyverse. Uma tabela é considerada tidy quando:\n\nCada variável é uma coluna\nCada observação é uma linha\nCada valor é uma célula (e cada célula é apenas um valor)\n\nOutros grupos de funções que valem a pena estudar são: separate(), case_when(), complete() e as funções de junção de tabelas. É possível encontrar essas informações no cheat-sheet do dplyr e no cheat-sheet do tidyr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#visualização-de-dados",
    "href": "blog/blogposts/test/index.html#visualização-de-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Visualização de dados",
    "text": "Visualização de dados\nggplot2 é um sistema moderno de visualização de dados extremamente versátil. Diferente do sistema de gráficos do R base, no ggplot2 uma gramática diferente é usada. A gramática dos gráficos (gg) consiste na soma de inúmeros e independentes camadas ou objetos combinados usando o + para construir o gráfico.\nggplot2 diferencia entre dados, o que é demonstrado e como é demonstrado.\n\ndados: os dados a serem utilizados (data.frame ou tibble).\nestética: a função aes() indica as variáveis que correspondem aos axis x,y,z, ou quando é pretendido aplicar parâmetros gráficos (como cores, tamanhos e formatos) conforme o com o gráfico. É possível incluir aes() na função ggplot() ou na função correspondente a uma geometria geom_*.\ngeometria: objetos geom_* indicam qual geometria a ser usada (geom_point(), geom_line(), geom_boxplot(), etc.).\nescalas: objetos do tipo scales_* manipulam axis, definem escala de cores, etc.\nestatísticas: objetos stat_* permitem aplicar transformações estatísticas.\n\n\nGráfico de linha e de disperção\n\n# install.packages(ggthemes)\nlibrary(ggthemes)\n\ntidyr::table1 |&gt; \n    ggplot(aes(year, cases)) +\n    geom_line(aes(color = country), linewidth = 1) +\n    scale_color_colorblind() +\n    scale_x_continuous(breaks = c(1999, 2000)) +\n    labs(\n        title = \"Casos de tuberculose\",\n        subtitle = \"Número de casos de tuberculose no Afeganistão, Brasil e China.\",\n        x = \"\",\n        y = \"\",\n        color = \"País\"\n    )\n\n\n\n\n\n\n\n\n\npenguins |&gt; \n    ggplot(aes(body_mass_g, flipper_length_mm)) +\n    geom_point(aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    scale_color_colorblind() +\n    labs(\n        title = \"Massa corporal e comprimento da nadadeira\",\n        subtitle = \"Dimensões para penguins das espécies Adelie, Chinstrap, e Gentoo\",\n        x = \"Comprimento da nadadeira (mm)\",\n        y = \"Massa corporal (g)\",\n        color = \"Espécies\",\n        shape = \"Espécies\"\n    )\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\npenguins |&gt; \n    ggplot(aes(species, body_mass_g)) +\n    geom_boxplot(aes(fill = species)) +\n    theme_minimal()\n\n\n\n\n\n\n\n\nHá tantas coisas que podemos fazer com o ggplot2 que merece uma postagem somente dedicada a esse pacote. Independente se é necessário contruir um box plot, gráfico de densidade, séries temporais, etc, o ggplot2 tem uma função para isso. Você também pode checar o cheat-sheet do ggplot2]"
  },
  {
    "objectID": "blog/blogposts/test/index.html#aplicar-funções-em-vetores-ou-listas",
    "href": "blog/blogposts/test/index.html#aplicar-funções-em-vetores-ou-listas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Aplicar funções em vetores ou listas",
    "text": "Aplicar funções em vetores ou listas\nO pacote purrr, além de ter o melhor nome de pacote de todos os tempos, é recheado de funções avançadas de programação funcional para vetores e listas. O lapply do R base corresponde ao map() do purrr.\n\n# lista de dois vetores\nlista_vec &lt;- list(x = 1:10, y = 50:70)\n\n# calcula a média para cada\nmap(lista_vec, mean)\n\n$x\n[1] 5.5\n\n$y\n[1] 60\n\n# muda o tipo de output do map_* (dbl, chr, lgl, etc.)\nmap_dbl(lista_vec, mean)\n\n   x    y \n 5.5 60.0 \n\n\nPara mais detalhes e exemplos podem ser encontrados no cheat-sheet do purrr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html",
    "href": "blog/blogposts/introducao-tidyverse/index.html",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "",
    "text": "O tidyverse, uma coleção de pacotes focados em ciência de dados, é um dos principais atrativos da linguagem de programação R. Nesta postagem serão sintetizados os principais aspectos necessários para o início da jornada na ciência de dados com o tidyverse."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#importar-e-salvar-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#importar-e-salvar-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importar e salvar dados",
    "text": "Importar e salvar dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos os dados Palmer Penguins, dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv() ou read_csv2( )\nImporta .CSV (vírgula ou ponto e vírgula)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# Assinala o arquivo penguins.csv, que está na pasta \"data\", ao objeto \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Inspeciona o conteúdo do objeto \"penguins\"\npenguins\n\n# A tibble: 344 × 9\n   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1     1 Adelie  Torgersen           39.1          18.7               181\n 2     2 Adelie  Torgersen           39.5          17.4               186\n 3     3 Adelie  Torgersen           40.3          18                 195\n 4     4 Adelie  Torgersen           NA            NA                  NA\n 5     5 Adelie  Torgersen           36.7          19.3               193\n 6     6 Adelie  Torgersen           39.3          20.6               190\n 7     7 Adelie  Torgersen           38.9          17.8               181\n 8     8 Adelie  Torgersen           39.2          19.6               195\n 9     9 Adelie  Torgersen           34.1          18.1               193\n10    10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#trabalhando-com-caracteres",
    "href": "blog/blogposts/introducao-tidyverse/index.html#trabalhando-com-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Trabalhando com caracteres",
    "text": "Trabalhando com caracteres\nPara trabalhar com caracteres (strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\nFunção\nDescrição\n\n\n\nstr_replace()\nSubstitui padrões\n\n\nstr_c()\nCombina caracteres\n\n\nstr_detect()\nDetecta padrões\n\n\nstr_extract()\nExtrai padrões\n\n\nstr_sub()\nExtrai por posição\n\n\nstr_length()\nRetorna o tamanho de uma string\n\n\n\n\nÉ comum o uso de expressões regulares (regex) para detecção de padrões. Abaixo temos alguns exemplos de funções do stringr em ação em conjunto com o uso de regex.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n#&gt;  [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n#&gt;  [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\"\n\n# substituir 'ber' com espaço vazio\nstr_replace(month.name, pattern = \"ber$\", \"\")\n#&gt;  [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n#&gt;  [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n#&gt;  [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n#&gt;  [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n#&gt; [11] \"November_11\" \"December_12\"\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n#&gt; [1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n# detectar padrão\nstr_detect(month.name, pattern = \"^A\")\n#&gt;  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n# extrair padrão\nstr_extract(month.name, pattern = \"ber$\")\n#&gt;  [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, start = 1, end = 2)\n#&gt;  [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n# tamanho da string de cada mês\nstr_length(month.name)\n#&gt;  [1] 7 8 5 5 3 4 4 6 9 7 8 8\n\nMais detalhes sobre as funções e expressões regulares podem ser encontrados no cheat-sheet do stringr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#gerenciamento-de-datas-e-horas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#gerenciamento-de-datas-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de datas e horas",
    "text": "Gerenciamento de datas e horas\nO pacote lubridate é excelente para lidar com datas e horas. Apenas devemos conhecer as seguintes abreviações:\n\n\nymd signfica y:year (ano), m:month (mês), d:day (dia)\n\nhms signfica h:hour (hora), m:minutes (minutos), s:seconds (segundos)\n\n\n# vetor com datas\ndatas &lt;- c(\"2020/12/31\", \"2012/05/04\", \"2003/09/24\",\"2017/11/24\")\n\n# vetor com datas e horas\ndatas_horas &lt;- c(\"1973-08-11 02:00\", \"2009-06-13 20:00\")\n\ndatas &lt;- ymd(datas)\ndatas\n#&gt; [1] \"2020-12-31\" \"2012-05-04\" \"2003-09-24\" \"2017-11-24\"\n\ndmy(\"13-08-2002\")\n#&gt; [1] \"2002-08-13\"\nymd(\"20020813\")\n#&gt; [1] \"2002-08-13\"\n\n# extrair o ano\nyear(datas)\n#&gt; [1] 2020 2012 2003 2017\n\n# extrair o mês\nmonth(datas)\n#&gt; [1] 12  5  9 11\n\n# extrair o dia da semana\nwday(datas)\n#&gt; [1] 5 6 4 6\n\n# extrair a hora\nhour(datas_horas)\n#&gt; [1]  2 20\n\n# adiciona 10 dias\ndatas + days(10)\n#&gt; [1] \"2021-01-10\" \"2012-05-14\" \"2003-10-04\" \"2017-12-04\"\n\n# adiciona 1 mês\ndatas + month(1)\n#&gt; [1] \"2021-01-01\" \"2012-05-05\" \"2003-09-25\" \"2017-11-25\"\n\nPara mais detalhes, veja o cheat-sheet do lubridate."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#transformação-de-tabelas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#transformação-de-tabelas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de tabelas",
    "text": "Transformação de tabelas\nOs pacotes dplyr e tidyr oferecem gramática para a transformação de dados, ou seja, um conjunto de verbos úteis para resolver problemas. As funções mais importantes são:\n\n\nFunção\nDescrição\n\n\n\nmutate()\nAdiciona ou modifica variáveis\n\n\nselect()\nSeleciona variábeis\n\n\nfilter()\nAplica filtro\n\n\nsummarise()\nReduz variáveis\n\n\nrename()\nRenomeia colunaas\n\n\n\n\nselect() e rename()\n\nConseguimos selecionar ou remover colunas com a função select(), usando o nome ou índice da coluna. Para deletar colunas apenas usamos o ponto de exclamação antes do nome ou índice da coluna. A função rename()renomeia colunas da mesma forma, usando o nome ou índice da coluna.\n\n# Assinala o resultado da cadeia ao objeto \"penguins_2\" \npenguins_2 &lt;- penguins |&gt; \n    # Seleciona a coluna \"rowid\".\n    # O ponto de exclamação indica a remoção da coluna \"rowid\"\n    select(!rowid) |&gt; \n    # Renomeia a coluna \"species\" como \"penguin_species\"\n    rename(penguin_species = species)\n\n# Visualizando o novo objeto\npenguins_2\n#&gt; # A tibble: 344 × 8\n#&gt;   penguin_species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;           &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie          Torgersen           39.1          18.7               181\n#&gt; 2 Adelie          Torgersen           39.5          17.4               186\n#&gt; 3 Adelie          Torgersen           40.3          18                 195\n#&gt; 4 Adelie          Torgersen           NA            NA                  NA\n#&gt; 5 Adelie          Torgersen           36.7          19.3               193\n#&gt; 6 Adelie          Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nfilter()e sort()\n\nPara filtrar dados, usamos o verbo filter() com operadores lógicos (&gt;, ==, etc.) ou funções retornando em valores lógicos (str_detect(), is.na()). A função arrange() classifica os valores de menor para maior ou classifica múltiplas variáveis.\n\npenguins_2 |&gt;\n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Dream\"\n    filter(island == \"Dream\") |&gt; \n    # Classifica os dados pela coluna \"year\"\n    arrange(year)\n#&gt; # A tibble: 124 × 8\n#&gt;   penguin_species island bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Adelie          Dream            39.5          16.7               178\n#&gt; 2 Adelie          Dream            37.2          18.1               178\n#&gt; 3 Adelie          Dream            39.5          17.8               188\n#&gt; 4 Adelie          Dream            40.9          18.9               184\n#&gt; 5 Adelie          Dream            36.4          17                 195\n#&gt; 6 Adelie          Dream            39.2          21.1               196\n#&gt; # ℹ 118 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nsummarise()\nComo encontramos a média do tamanho dos bicos dos pinguins na ilha de Biscoe, por espécie de pinguim?\nPara encontrarmos a resposta, devemos filtrar os dados pela ilha Biscoe e então agrupar por espécies. Quando usamos a função summarise(), podemos agrupar os dados para executarmos a redução dos dados.\n\npenguins_2 |&gt; \n    # Filtra linhas em que o conteúdo da coluna \"island\" seja igual a \"Biscoe\"\n    filter(island == \"Biscoe\") |&gt; \n    # Cálculo da média da coluna \"bill_length_mm\" através da função mean()\n    # O resultado do cálculo será assinalado a nova coluna \"bill_length_mm_mean\"\n    # O segundo parâmetro (na.rm = TRUE) remove os dados não identificados (NAs)\n    # O cálculo é aplicado ao agrupamento de cada espécie, na coluna \"penguin_species\"\n    summarise(\n        bill_length_mm_mean = mean(bill_length_mm, na.rm = TRUE),\n        .by = penguin_species\n    ) |&gt; \n    # Classifica a tabela resultante pelo tamanho do bico\n    arrange(bill_length_mm_mean)\n#&gt; # A tibble: 2 × 2\n#&gt;   penguin_species bill_length_mm_mean\n#&gt;   &lt;chr&gt;                         &lt;dbl&gt;\n#&gt; 1 Adelie                         39.0\n#&gt; 2 Gentoo                         47.5\n\nTabelas longas ou largas\nÉ muito comum modificar tabelas nos dois formatos: longas ou largas. Tabelas longas são mais comuns para trabalhar dados, porém muitas vezes os dados que se tem em mãos são estruturados em tabelas largas ou em algumas ocasiões tabelas longas são desejadas.\n\n# Tabela larga\ntidyr::table4a\n#&gt; # A tibble: 3 × 3\n#&gt;   country     `1999` `2000`\n#&gt;   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan    745   2666\n#&gt; 2 Brazil       37737  80488\n#&gt; 3 China       212258 213766\n\n# Tabela larga para tabela longa\ntable4a_long &lt;- tidyr::table4a |&gt; \n    pivot_longer(\n        cols = !country,\n        names_to = \"year\",\n        values_to = \"cases\"\n    )\n\n# Tabela longa\ntable4a_long\n#&gt; # A tibble: 6 × 3\n#&gt;   country     year   cases\n#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan 1999     745\n#&gt; 2 Afghanistan 2000    2666\n#&gt; 3 Brazil      1999   37737\n#&gt; 4 Brazil      2000   80488\n#&gt; 5 China       1999  212258\n#&gt; 6 China       2000  213766\n\n# Tabela longa para tabela larga novamente\ntable4a_long |&gt; \n    pivot_wider(\n        names_from = year,\n        values_from = cases\n    )\n#&gt; # A tibble: 3 × 3\n#&gt;   country     `1999` `2000`\n#&gt;   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan    745   2666\n#&gt; 2 Brazil       37737  80488\n#&gt; 3 China       212258 213766\n\nDe fato, o uso de tabelas longas dá origem ao termo tabelas tidy, o modelo de estruturação de dados ideal para data science, e que eventualmente nomeia o tidyverse. Uma tabela é considerada tidy quando:\n\nCada variável é uma coluna\nCada observação é uma linha\nCada valor é uma célula (e cada célula é apenas um valor)\n\nOutros grupos de funções que valem a pena estudar são: separate(), case_when(), complete() e as funções de junção de tabelas. É possível encontrar essas informações no cheat-sheet do dplyr e no cheat-sheet do tidyr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#visualização-de-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#visualização-de-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Visualização de dados",
    "text": "Visualização de dados\nggplot2 é um sistema moderno de visualização de dados extremamente versátil. Diferente do sistema de gráficos do R base, no ggplot2 uma gramática diferente é usada. A gramática dos gráficos (gg) consiste na soma de inúmeros e independentes camadas ou objetos combinados usando o + para construir o gráfico.\nggplot2 diferencia entre dados, o que é demonstrado e como é demonstrado.\n\n\ndados: os dados a serem utilizados (data.frame ou tibble).\n\nestética: a função aes() indica as variáveis que correspondem aos axis x,y,z, ou quando é pretendido aplicar parâmetros gráficos (como cores, tamanhos e formatos) conforme o com o gráfico. É possível incluir aes() na função ggplot() ou na função correspondente a uma geometria geom_*.\n\ngeometria: objetos geom_* indicam qual geometria a ser usada (geom_point(), geom_line(), geom_boxplot(), etc.).\n\nescalas: objetos do tipo scales_* manipulam axis, definem escala de cores, etc.\n\nestatísticas: objetos stat_* permitem aplicar transformações estatísticas.\n\n\n\nLineplot\nScatterplot\nBoxplot\n\n\n\n\nCódigolibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(gapminder)\n\ngapmminder_clean &lt;- gapminder |&gt; \n  summarise(\n    mean_lifeexp = mean(lifeExp),\n    .by = c(continent, year)\n  ) |&gt; \n  mutate(\n    continent = case_when(\n    continent == \"Africa\"   ~ \"África\",\n    continent == \"Americas\" ~ \"Américas\",\n    continent == \"Asia\"     ~ \"Ásia\",\n    continent == \"Europe\"   ~ \"Europa\",\n    TRUE ~ \"Oceania\"\n    )\n  )\n\ngapmminder_clean |&gt; \n  ggplot(aes(year, mean_lifeexp)) +\n  geom_line(aes(color = continent), linewidth = 1) +\n  scale_color_colorblind() +\n  labs(\n    title =    \"Expectativa de vida por continente\",\n    subtitle = \"Expectativa média de vida ao longo dos anos, por continente\",\n    x =        element_blank(),\n    y =        \"Expectativa de vida média\",\n    caption =  \"Fonte: Pacote R Gapminder\"\n  ) +\n  theme(\n    plot.title =          element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    legend.position =     \"top\",\n    legend.title =        element_blank(),\n    legend.key =          element_rect(color = NA, fill = NA),\n    panel.grid.minor =    element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nCódigolibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(palmerpenguins)\n\npenguins |&gt; \n    ggplot(aes(body_mass_g, flipper_length_mm)) +\n    geom_point(aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    scale_color_colorblind() +\n    labs(\n        title =    \"Massa corporal e comprimento da nadadeira\",\n        subtitle = \"Dimensões para pinguins das espécies Adelie, Chinstrap e Gentoo\",\n        caption =  \"Fonte: Pacote R Palmerpenguins\",\n        x =        \"Comprimento da nadadeira (mm)\",\n        y =        \"Massa corporal (g)\",\n        color =    \"Espécies\",\n        shape =    \"Espécies\"\n    ) +\n    theme(\n      plot.title =            element_text(face = \"bold\"),\n      plot.title.position =   \"plot\",\n      plot.caption.position = \"plot\",\n      legend.key =            element_rect(colour = NA, fill = NA),\n      panel.grid.minor =      element_blank()\n    )\n\n\n\n\n\n\n\n\n\n\nCódigolibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(palmerpenguins)\n\npenguins |&gt; \n    ggplot(aes(species, body_mass_g)) +\n    geom_boxplot(aes(fill = species)) +\n    scale_fill_colorblind() +\n    labs(\n        title =    \"Massa corporal de espécies de pinguim\",\n        subtitle = \"Dimensões para pinguins das espécies Adelie, Chinstrap e Gentoo\",\n        caption =  \"Fonte: Pacote R Palmerpenguins\",\n        x =        element_blank(),\n        y =        \"Massa corporal (g)\",\n        fill =     \"Espécies\"\n    ) +\n    theme(\n        plot.title =            element_text(face = \"bold\"),\n        plot.title.position =   \"plot\",\n        plot.caption.position = \"plot\",\n        legend.key =            element_rect(colour = NA, fill = NA),\n        panel.grid.minor =      element_blank()\n    )\n\n\n\n\n\n\n\n\n\n\nHá tantas coisas que podemos fazer com o ggplot2 que merece uma postagem somente dedicada a esse pacote. Independente se é necessário contruir um box plot, gráfico de densidade, séries temporais, etc, o ggplot2 tem uma função para isso. Você também pode checar o cheat-sheet do ggplot2."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#aplicar-funções-em-vetores-ou-listas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#aplicar-funções-em-vetores-ou-listas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Aplicar funções em vetores ou listas",
    "text": "Aplicar funções em vetores ou listas\nO pacote purrr, além de ter o melhor nome de pacote de todos os tempos, é recheado de funções avançadas de programação funcional para vetores e listas. O lapply do R base corresponde ao map() do purrr.\n\n# lista de dois vetores\nlista_vec &lt;- list(x = 1:10, y = 50:70)\n\n# calcula a média para cada\nmap(lista_vec, mean)\n#&gt; $x\n#&gt; [1] 5.5\n#&gt; \n#&gt; $y\n#&gt; [1] 60\n\n# muda o tipo de output do map_* (dbl, chr, lgl, etc.)\nmap_dbl(lista_vec, mean)\n#&gt;    x    y \n#&gt;  5.5 60.0\n\nPara mais detalhes e exemplos podem ser encontrados no cheat-sheet do purrr."
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html",
    "href": "blog/blogposts/importacao-excel/index.html",
    "title": "Planilhas do Excel no R",
    "section": "",
    "text": "Geralmente trabalhamos com diversas fontes de dados. Uma das formas mais comuns de armazenamento de dados são os arquivos em formato Excel, com as extensões .xls e .xlsx. Nesta postagem vamos explorar as funcionalidades do readxl, um pacote parte do tidyverse que facilita a importação de dados do Excel para o R."
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html#intervalo-de-células",
    "href": "blog/blogposts/importacao-excel/index.html#intervalo-de-células",
    "title": "Planilhas do Excel no R",
    "section": "Intervalo de células",
    "text": "Intervalo de células\nExitem diversas formas de sinalizar quais células devem ser lidas. É até possível especificar a planilha em específico, se for fornecido um intervalo no estilo do Excel.\n\n# Número máximo de linhas para importar\nread_excel(example_xlsx, n_max = 3)\n#&gt; # A tibble: 3 × 11\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n\n# Número de linhas para pular\nread_excel(example_xlsx, skip = 3)\n#&gt; New names:\n#&gt; • `4` -&gt; `4...2`\n#&gt; • `1` -&gt; `1...8`\n#&gt; • `1` -&gt; `1...9`\n#&gt; • `4` -&gt; `4...10`\n#&gt; • `1` -&gt; `1...11`\n#&gt; # A tibble: 29 × 11\n#&gt;   `22.8` `4...2` `108`  `93` `3.85` `2.3199999999999998` `18.61` `1...8`\n#&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;                &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1   21.4       6  258    110   3.08                 3.22    19.4       1\n#&gt; 2   18.7       8  360    175   3.15                 3.44    17.0       0\n#&gt; 3   18.1       6  225    105   2.76                 3.46    20.2       1\n#&gt; 4   14.3       8  360    245   3.21                 3.57    15.8       0\n#&gt; 5   24.4       4  147.    62   3.69                 3.19    20         1\n#&gt; 6   22.8       4  141.    95   3.92                 3.15    22.9       1\n#&gt; # ℹ 23 more rows\n#&gt; # ℹ 3 more variables: `1...9` &lt;dbl&gt;, `4...10` &lt;dbl&gt;, `1...11` &lt;dbl&gt;\n\n# Intervalo de linhas e colunas para importar\nread_excel(example_xlsx, range = \"C1:E4\")\n#&gt; # A tibble: 3 × 3\n#&gt;    disp    hp  drat\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1   160   110  3.9 \n#&gt; 2   160   110  3.9 \n#&gt; 3   108    93  3.85\n\n# Intervado de linhas para importar\nread_excel(example_xlsx, range = cell_rows(1:4))\n#&gt; # A tibble: 3 × 11\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n\n# Intervalo de colunas para importar\nread_excel(example_xlsx, range = cell_cols(\"B:D\"))\n#&gt; # A tibble: 32 × 3\n#&gt;     cyl  disp    hp\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     6   160   110\n#&gt; 2     6   160   110\n#&gt; 3     4   108    93\n#&gt; 4     6   258   110\n#&gt; 5     8   360   175\n#&gt; 6     6   225   105\n#&gt; # ℹ 26 more rows\n\n# Intervalo de linhas e colunas de uma planilha específica\nread_excel(example_xlsx, range = \"mtcars!B1:D5\")\n#&gt; # A tibble: 4 × 3\n#&gt;     cyl  disp    hp\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     6   160   110\n#&gt; 2     6   160   110\n#&gt; 3     4   108    93\n#&gt; 4     6   258   110"
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html#especificação-de-colunas",
    "href": "blog/blogposts/importacao-excel/index.html#especificação-de-colunas",
    "title": "Planilhas do Excel no R",
    "section": "Especificação de colunas",
    "text": "Especificação de colunas\nEspecificação de colunas é o que define que tipo de dado cada coluna do arquivo Excel será ao ser importado. Por padrão, o read_excel() analisa as primeiras 1000 observações e faz um chute educado sobre qual tipo de dado cada variável possui. É possível aumentar o número de linhas com o parâmetro guess_max.\nPara especificar o tipo de dado de colunas, usamos o parâmetro col_types. Para definir todas as variáveis como, por exemplo, strings, usamos:\n\nread_excel(example_xlsx, col_types = \"text\")\n#&gt; # A tibble: 32 × 11\n#&gt;   mpg                cyl   disp  hp    drat  wt               qsec           \n#&gt;   &lt;chr&gt;              &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;            &lt;chr&gt;          \n#&gt; 1 21                 6     160   110   3.9   2.62             16.46          \n#&gt; 2 21                 6     160   110   3.9   2.875            17.02          \n#&gt; 3 22.8               4     108   93    3.85  2.3199999999999… 18.61          \n#&gt; 4 21.4               6     258   110   3.08  3.2149999999999… 19.44000000000…\n#&gt; 5 18.7               8     360   175   3.15  3.44             17.02          \n#&gt; 6 18.100000000000001 6     225   105   2.76  3.46             20.22          \n#&gt; # ℹ 26 more rows\n#&gt; # ℹ 4 more variables: vs &lt;chr&gt;, am &lt;chr&gt;, gear &lt;chr&gt;, carb &lt;chr&gt;\n\nPara definir cada coluna individualmente, podemos fazer o seguinte:\n\nread_excel(\n    example_xlsx,\n    sheet = \"quakes\",\n    col_types = c(\"numeric\", \"numeric\", \"numeric\", \"numeric\", \"guess\")\n)\n#&gt; # A tibble: 1,000 × 5\n#&gt;     lat  long depth   mag stations\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 -20.4  182.   562   4.8       41\n#&gt; 2 -20.6  181.   650   4.2       15\n#&gt; 3 -26    184.    42   5.4       43\n#&gt; 4 -18.0  182.   626   4.1       19\n#&gt; 5 -20.4  182.   649   4         11\n#&gt; 6 -19.7  184.   195   4         12\n#&gt; # ℹ 994 more rows\n\nOs tipos de colunas disponíveis são:\n\nSkip (pula uma coluna)\nGuess (chuta um tipo)\nLogicals (valores lógicos)\nNumeric (numéricos)\nText (texto)\nDate (datas)\nList (listas, para múltiplos tipos de dados)\n\nExemplos:\n\n\nlogical\nnumeric\ntext\ndate\nlist\n\n\n\nTRUE\n2\nhello\n1999-01-01\nworld\n\n\nFALSE\n3.14\nworld\n2004-02-21\n1"
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html",
    "href": "blog/blogposts/introducao-git-github/index.html",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "",
    "text": "R é uma ferramenta que busca auxiliar cientistas analizarem dados e que possui inúmeras excelentes funções built-in para a produção de gráficos e de modelos estatísticos. Consequentemente, muitos usuários do R usam a ferramenta como um software, aprendendo apenas quais funções necessárias para atingir seus objetivos e ignorando todo o resto.\nAprender apenas as funções necessárias do R para determinada tafera, como ciência de dados, é compreensível. De todo modo, aprender a programar e como a linguagem de programação R funciona deve estar nos planos de todo cientista de dados. Saber programar fará você um analista mais flexível e irá aprimorar sua excelência em data science em todos os aspectos, entender os fundamentos do R faz todo o processo de aprendizagem mais simples.\nPrimeiramente iremos aprender como baixar e instalar o R na sua máquina, baixar e instalar o RStudio e conhecer o seu layout de trabalho."
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#instalando-o-r-e-rstudio",
    "href": "blog/blogposts/introducao-git-github/index.html#instalando-o-r-e-rstudio",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "Instalando o R e RStudio",
    "text": "Instalando o R e RStudio\nPara começar, você deve ter sua própria cópia do R. Para nossa sorte, o R é totalmente gratuito e fácil de baixar.\nR é gerenciado por um time de desenvolvedores que fazem a linguagem de programação disponível no CRAN. O CRAN oferece opções de download para o Windows, Mac e Linux.\nWindows: Para instalar o R no Windows, selecione o link de download para Windows, no CRAN. Tenha certeza de escolher a versão “base” do R. Você vai baixar um instalador de programa. Execute o instalador. O instalador irá instalar o R no seu computador e adicionar um atalho na sua área de trabalho.\nMac: Para instalar o R no Mac, selecione o link de download para Mac. Clique no pacote da versão mais recente do R. Um instalador irá guiar o processo de instalação, onde os padrões são sensatos para a maioria dos usuários.\nLinux: O R já vem pré-instalado em diversas distribuições Linux, mas você vai querer a versão mais recente do R se a sua estiver desatualizada. O CRAN oferece arquivos para as principais distros pelo link de download para Linux. O processo de instalação varia para cada distro. O CRAN demonstra o processo em sua documentação."
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#usando-r",
    "href": "blog/blogposts/introducao-git-github/index.html#usando-r",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "Usando R",
    "text": "Usando R\nO R não é um programa que você simplesmente dá dois clicks para começar a usar, como o Microsoft Word ou Google Chrome. R é uma linguagem de programação, como Python, C, Javascript ou Rust. A maneira de usar o R é escrever comandos na linguagem R e pedir para seu computador interpretá-los. Antigamente, as pessoas executavam o código em R diretamente na linha de comando. Hoje em dia quase todo mundo usa um aplicativo para escrever código em R chamado RStudio e eu recomendo que você faça o mesmo.\n\n\n\nA linguagem de programação R no terminal."
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#a-interface-do-r",
    "href": "blog/blogposts/introducao-git-github/index.html#a-interface-do-r",
    "title": "Uma introdução ao R",
    "section": "A interface do R",
    "text": "A interface do R\nAntes de você entrar em contato com o seu computador, primeiro você deverá aprender a como falar com ele. É nessa parte que o R e o RStudio entram em cena. RStudio é a forma de como se comunicar com o seu computador. R é o idioma que você conversa com ele.\nPara darmos início, abra o RStudio como qualquer outro programa"
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#rstudio",
    "href": "blog/blogposts/introducao-git-github/index.html#rstudio",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "RStudio",
    "text": "RStudio\nAgora sim, Rstudio é um programa como o Microsoft Word ou Google Chrome, exceto que ao invés de te ajudar a escrever em português ou navegar na internet, o RStudio te ajuda a em escrever em R e a criar scripts. Existem outros aplicativos para auxiliar o código em R, mas recomendo o RStudio pois ele faz escrever código em R (e em outras linguagens de programação, como Python) muito mais simples.\nVocê pode baixar o RStudio de graça, apenas seguir os passos no site da Posit. Uma vez instalado o RStudio, você pode abrir como um programa qualquer.\n\n\n\nPara baixar a última versão do Rstudio, apenas clique no link do arquivo de acordo com o sistema operacional de sua máquina.\n\n\nQuando você abre o RStudio, uma janela aparece com três painés. O maior painel é uma janela do console (onde o código em R é executado e onde os resultados são observados). O painel do console é exatamente o que você veria se usasse o R em linha de comando. Todo o resto é único do RStudio. Em outros painéis estão um editor de texto, uma janela para gráficos, um gerenciador de arquivos e muito mais. Para o painel do editor de texto (também chamado source) aparecer no layout do RStudio, basta criar um script do R (Arquivo &gt; Novo Arquivo &gt; R Scripts ou pelo atalho Ctrl + Shift + N)."
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#a-ui-do-r",
    "href": "blog/blogposts/introducao-git-github/index.html#a-ui-do-r",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "A UI do R",
    "text": "A UI do R\nAntes de você entrar em contato com o seu computador, primeiro você deverá aprender a como falar com ele. É nessa parte que o R e o RStudio entram em cena. RStudio é a forma de como se comunicar com o seu computador. R é o idioma que você conversa com ele.\nPara darmos início, abra o RStudio como outro programa qualquer. Quando você abre o RStudio, uma janela deve aparecer na sua tela como essa janela abaixo.\n\n\n\nLayout padrão do RStudio. A seta azul é onde está localizada a linha de comando.\n\n\nSeu computador recebe seus comandos quando você escreve código em R no final do painel do console. Não esqueça de pressionar o botão de Enter para que o comando seja executado. O console aparece no painel da esquerda, mas você pode mudar o layout dos painés se preferir, em Arquivo &gt; Preferências.\nA interface do RStudio é simples. Você escreve seu código em R na última linha do painel do Console no RStudio e pressiona Enter para executar. O código que você escreve é chamado de comando, pois você está dando uma ordem ao computador para fazer algo para você. A linha em que você escreve o comando é chamada de linha de comando.\nQuando você digita um comando na linha de comando e pressiona Enter, seu computador executa o comando e mostra os resultados. Por exemplo, se você digitar 1 + 1 e pressionar Enter, o RStudio vai mostrar o seguinte:\n\n1 + 1\n\n[1] 2\n\n\nEssa é sua primeira mensagem na linguagem de programação R. Para iniciar a falar em R com o seu computador, fique atento aos próximos posts no blog."
  },
  {
    "objectID": "blog/blogposts/introducao-git-github/index.html#a-ui-do-rstudio",
    "href": "blog/blogposts/introducao-git-github/index.html#a-ui-do-rstudio",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "A UI do Rstudio",
    "text": "A UI do Rstudio\nAntes de você entrar em contato com o seu computador, primeiro você deverá aprender a como falar com ele. É nessa parte que o R e o RStudio entram em cena. RStudio é a forma de como se comunicar com o seu computador. R é o idioma que você conversa com ele.\nPara darmos início, abra o RStudio como outro programa qualquer."
  },
  {
    "objectID": "blog/blogposts/introducao-r/index.html",
    "href": "blog/blogposts/introducao-r/index.html",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "",
    "text": "R é uma ferramenta que busca auxiliar cientistas analizarem dados e que possui inúmeras excelentes funções built-in para a produção de gráficos e de modelos estatísticos. Consequentemente, muitos usuários do R usam a ferramenta como um software, aprendendo apenas quais funções necessárias para atingir seus objetivos e ignorando todo o resto.\nAprender apenas as funções necessárias do R para determinada tafera, como ciência de dados, é compreensível. De todo modo, aprender a programar e como a linguagem de programação R funciona deve estar nos planos de todo cientista de dados. Saber programar fará você um analista mais flexível e irá aprimorar sua excelência em data science em todos os aspectos, entender os fundamentos do R faz todo o processo de aprendizagem mais simples.\nPortanto, abordaremos a instalação do R e do RStudio, exploraremos a interface do RStudio e daremos os primeiros passos na linguagem R."
  },
  {
    "objectID": "blog/blogposts/introducao-r/index.html#a-ui-do-r",
    "href": "blog/blogposts/introducao-r/index.html#a-ui-do-r",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "A UI do R",
    "text": "A UI do R\nAntes de você entrar em contato com o seu computador, primeiro você deverá aprender a como falar com ele. É nessa parte que o R e o RStudio entram em cena. RStudio é a forma de como se comunicar com o seu computador. R é o idioma que você conversa com ele.\nPara darmos início, abra o RStudio como outro programa qualquer. Quando você abre o RStudio, uma janela deve aparecer na sua tela como essa janela abaixo.\n\n\nLayout padrão do RStudio. A seta azul é onde está localizada a linha de comando.\n\nSeu computador recebe seus comandos quando você escreve código em R no final do painel do console. Não esqueça de pressionar o botão de Enter para que o comando seja executado. O console aparece no painel da esquerda, mas você pode mudar o layout dos painés se preferir, em Arquivo &gt; Preferências.\nA interface do RStudio é simples. Você escreve seu código em R na última linha do painel do Console no RStudio e pressiona Enter para executar. O código que você escreve é chamado de comando, pois você está dando uma ordem ao computador para fazer algo para você. A linha em que você escreve o comando é chamada de linha de comando.\nQuando você digita um comando na linha de comando e pressiona Enter, seu computador executa o comando e mostra os resultados. Por exemplo, se você digitar 1 + 1 e pressionar Enter, o RStudio vai mostrar o seguinte:\n\n1 + 1\n#&gt; [1] 2\n\nEssa é sua primeira mensagem na linguagem de programação R. Para iniciar a falar em R com o seu computador, fique atento aos próximos posts no blog."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#importar-e-exportar-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#importar-e-exportar-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importar e exportar dados",
    "text": "Importar e exportar dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos o dataset Palmer Penguins, que contém dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv()\nImporta arquivos .csv (separados por ,)\n\n\nread_csv2()\nImporta arquivos .csv (separados por ;)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# Importa o arquivo penguins.csv, que está na pasta \"data\", ao objeto \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n#&gt; Rows: 344 Columns: 9\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (3): species, island, sex\n#&gt; dbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_ma...\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Inspeciona o conteúdo do objeto \"penguins\"\npenguins\n#&gt; # A tibble: 344 × 9\n#&gt;   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1     1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2     2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3     3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4     4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5     5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6     6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "contact/index.html",
    "href": "contact/index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Por favor, entre em contato comigo pela minha conta do LinkedIn ou mande uma mensagem por Email ou Whatsapp. Será um prazer conversar com você."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#importação-e-exportação-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#importação-e-exportação-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importação e exportação dados",
    "text": "Importação e exportação dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos o dataset Palmer Penguins, que contém dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\nFunção\nDescrição\n\n\n\nread_csv()\nImporta arquivos .csv (separados por ,)\n\n\nread_csv2()\nImporta arquivos .csv (separados por ;)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# read_csv() importa o arquivo penguins.csv, que está na pasta \"data\".\n# Assinalamos o conteúdo do arquivo .csv ao objeto chamado \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n#&gt; Rows: 344 Columns: 9\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (3): species, island, sex\n#&gt; dbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_ma...\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Ao visualizar o conteúdo do objeto \"penguins\" temos um tibble com dados,\n# pronto para trabalhar\npenguins\n#&gt; # A tibble: 344 × 9\n#&gt;   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1     1 Adelie  Torgersen           39.1          18.7               181\n#&gt; 2     2 Adelie  Torgersen           39.5          17.4               186\n#&gt; 3     3 Adelie  Torgersen           40.3          18                 195\n#&gt; 4     4 Adelie  Torgersen           NA            NA                  NA\n#&gt; 5     5 Adelie  Torgersen           36.7          19.3               193\n#&gt; 6     6 Adelie  Torgersen           39.3          20.6               190\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/using-across/index.html",
    "href": "blog/blogposts/using-across/index.html",
    "title": "Transformando dados com across( )",
    "section": "",
    "text": "Dentre as inúmeras ferramentas disponíveis no tidyverse, a função across() pode ser um recurso de grande utilidade para simplificar transformações aplicadas em múltiplas variáveis.\nUsando across( )\nQuando estamos inicando na ciência de dados em R e conhecendo a sintaxe do tidyverse, é muito comum escrevermos códigos parecidos como estes:\n\nlibrary(tidyverse)\n\npenguins &lt;- palmerpenguins::penguins\n\npenguins |&gt; \n    summarise(\n        mean_bill_length = mean(bill_length_mm, na.rm = TRUE),\n        mean_bill_depth = mean(bill_depth_mm, na.rm = TRUE),\n        mean_flipper_length = mean(flipper_length_mm, na.rm = TRUE),\n        mean_body_mass = mean(body_mass_g, na.rm = TRUE)\n    )\n#&gt; # A tibble: 1 × 4\n#&gt;   mean_bill_length mean_bill_depth mean_flipper_length mean_body_mass\n#&gt;              &lt;dbl&gt;           &lt;dbl&gt;               &lt;dbl&gt;          &lt;dbl&gt;\n#&gt; 1             43.9            17.2                201.          4202.\n\nNeste caso, estamos computando a mesma função mean() em diversas colunas. Porém, há uma maneira mais eficiente de fazer esta mesma operação usando a função across(), onde apenas devemos selecionar as variáveis nas quais desejamos trabalhar no parâmetro .cols e a função desejada no parâmetro .fns que, neste caso, é a função de média, mean().\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = c(\n                bill_length_mm, bill_depth_mm,\n                flipper_length_mm, body_mass_g\n            ),\n            .fns = \\(.x) mean(.x, na.rm = TRUE)\n        )\n    )\n#&gt; # A tibble: 1 × 4\n#&gt;   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1           43.9          17.2              201.       4202.\n\nNote que a função de média é aplicada em cada variável através da função anônima \\(.x) mean(.x, na.rm = TRUE), onde \\() equivale a function() e o .x corresponde as colunas listadas em .cols que serão utilizadas para calcular suas médias com mean().\nacross() também nos permite aplicar diversas funções ao mesmo tempo para as variáveis escolhidas em .cols. Para aplicar mais de uma função em across(), apenas é necessário inserir as funções num vetor, como vemos abaixo, calculamos a variâcia das variáveis em conjunto com suas médias no parâmetro .fns:\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = c(\n                bill_length_mm, bill_depth_mm,\n                flipper_length_mm, body_mass_g\n            ),\n            .fns = c(\n                mean = \\(.x) mean(.x, na.rm = TRUE),\n                var = \\(.x) mean(.x, na.rm = TRUE)\n            )\n        )\n    )\n#&gt; # A tibble: 1 × 8\n#&gt;   bill_length_mm_mean bill_length_mm_var bill_depth_mm_mean bill_depth_mm_var\n#&gt;                 &lt;dbl&gt;              &lt;dbl&gt;              &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1                43.9               43.9               17.2              17.2\n#&gt; # ℹ 4 more variables: flipper_length_mm_mean &lt;dbl&gt;,\n#&gt; #   flipper_length_mm_var &lt;dbl&gt;, body_mass_g_mean &lt;dbl&gt;, …\n\nObverse o output do código, onde cada variável resultou em duas variáveis, uma para cada estatística: média (mean()) e variância (var()). Infelizmente, o output deste código gera uma tibble em um formato largo (wide tibble), com oito variáveis e apenas uma observação, o que não é ideal para podermos trabalhar com ela. Felizmente, podemos usar mais um parâmetro do across() para facilitar nossas vidas, .names:\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = c(\n                bill_length_mm, bill_depth_mm,\n                flipper_length_mm, body_mass_g\n            ),\n            .fns = c(\n                mean = \\(.x) mean(.x, na.rm = TRUE),\n                var = \\(.x) mean(.x, na.rm = TRUE)\n            ),\n            .names = \"{.col}----{.fn}\"\n        )\n    ) \n#&gt; # A tibble: 1 × 8\n#&gt;   `bill_length_mm----mean` `bill_length_mm----var` `bill_depth_mm----mean`\n#&gt;                      &lt;dbl&gt;                   &lt;dbl&gt;                   &lt;dbl&gt;\n#&gt; 1                     43.9                    43.9                    17.2\n#&gt; # ℹ 5 more variables: `bill_depth_mm----var` &lt;dbl&gt;,\n#&gt; #   `flipper_length_mm----mean` &lt;dbl&gt;, `flipper_length_mm----var` &lt;dbl&gt;, …\n\n.names entra em cena para auxiliar nosso trabalho ao nos permitir modificar os nomes das variáveis inclusas em .cols. O parâmetro requer uma string, onde é possível adicionar {.col} para sinalizar o uso do nome da variável e {.fn} que indica o uso do nome da função (neste caso, ou mean, ou var). Entre eles, adicionei quatro traços ----, que servirá como separador e irá facilitar nossas vidas na transformação de uma wide tibble para uma long tibble, através do pivot_longer():\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = c(\n                bill_length_mm, bill_depth_mm,\n                flipper_length_mm, body_mass_g\n            ),\n            .fns = c(\n                mean = \\(.x) mean(.x, na.rm = TRUE),\n                var = \\(.x) mean(.x, na.rm = TRUE)\n            ),\n            .names = \"{.col}----{.fn}\"\n        )\n    ) |&gt; \n    pivot_longer(\n        cols = everything(),\n        names_sep = \"----\",\n        names_to = c(\"variable\", \"stat\")\n    )\n#&gt; # A tibble: 8 × 3\n#&gt;   variable          stat  value\n#&gt;   &lt;chr&gt;             &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 bill_length_mm    mean   43.9\n#&gt; 2 bill_length_mm    var    43.9\n#&gt; 3 bill_depth_mm     mean   17.2\n#&gt; 4 bill_depth_mm     var    17.2\n#&gt; 5 flipper_length_mm mean  201. \n#&gt; 6 flipper_length_mm var   201. \n#&gt; # ℹ 2 more rows\n\nAssim, a tibble fica muito mais amigável para criação de novas variáveis e para trabalhar com ela.\nUsando tidyselect helpers em conjunto com across( )\nOs helpers tidyselect são um grupo de verbos do tidyverse disponibilizadas para a seleção de variáveis. São úteis para podermos lidar com tibbles que possuem um número expressivo de variáveis, evitando digitação de muito código. Por exemplo, a tibble abaixo possui 74 variáveis:\n\names &lt;- modeldata::ames\n\names\n#&gt; # A tibble: 2,930 × 74\n#&gt;   MS_SubClass                    MS_Zoning       Lot_Frontage Lot_Area Street\n#&gt; * &lt;fct&gt;                          &lt;fct&gt;                  &lt;dbl&gt;    &lt;int&gt; &lt;fct&gt; \n#&gt; 1 One_Story_1946_and_Newer_All_… Residential_Lo…          141    31770 Pave  \n#&gt; 2 One_Story_1946_and_Newer_All_… Residential_Hi…           80    11622 Pave  \n#&gt; 3 One_Story_1946_and_Newer_All_… Residential_Lo…           81    14267 Pave  \n#&gt; 4 One_Story_1946_and_Newer_All_… Residential_Lo…           93    11160 Pave  \n#&gt; 5 Two_Story_1946_and_Newer       Residential_Lo…           74    13830 Pave  \n#&gt; 6 Two_Story_1946_and_Newer       Residential_Lo…           78     9978 Pave  \n#&gt; # ℹ 2,924 more rows\n#&gt; # ℹ 69 more variables: Alley &lt;fct&gt;, Lot_Shape &lt;fct&gt;, Land_Contour &lt;fct&gt;, …\n\nDigamos que queremos trabalhar com todas as variáveis numéricas do dataset ames. Ao invés de digitarmos todas as colunas, podemos utilizar os helpers tidyselect, como o where() em conjunto com is.numeric para selecionar todas as variáveis onde os resultados de is.numeric é igual a TRUE.\n\names |&gt; \n    summarise(\n        across(\n            .cols = where(is.numeric),\n            .fns = c(\n                mean = \\(.x) mean(.x, na.rm = TRUE),\n                var = \\(.x) mean(.x, na.rm = TRUE)\n            ),\n            .names = \"{.col}----{.fn}\"\n        )\n    ) |&gt; \n    pivot_longer(\n        cols = everything(),\n        names_sep = \"----\",\n        names_to = c(\"variable\", \"stat\")\n    )\n#&gt; # A tibble: 68 × 3\n#&gt;   variable     stat    value\n#&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 Lot_Frontage mean     57.6\n#&gt; 2 Lot_Frontage var      57.6\n#&gt; 3 Lot_Area     mean  10148. \n#&gt; 4 Lot_Area     var   10148. \n#&gt; 5 Year_Built   mean   1971. \n#&gt; 6 Year_Built   var    1971. \n#&gt; # ℹ 62 more rows\n\nTambém é possível usar mais helpers do tidyselect para filtrar ainda mais as colunas desejadas. Por exemplo, podemos combinar where(is.numeric) e starts_with(\"Lot\") para aplicar transformações apenas para as variáveis numéricas que iniciam com o padrão “Lot”.\n\names |&gt; \n    summarise(\n        across(\n            .cols = where(is.numeric) & starts_with(\"Lot\"),\n            .fns = c(\n                mean = \\(.x) mean(.x, na.rm = TRUE),\n                var = \\(.x) mean(.x, na.rm = TRUE)\n            ),\n            .names = \"{.col}----{.fn}\"\n        )\n    ) |&gt; \n    pivot_longer(\n        cols = everything(),\n        names_sep = \"----\",\n        names_to = c(\"variable\", \"stat\")\n    )\n#&gt; # A tibble: 4 × 3\n#&gt;   variable     stat    value\n#&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 Lot_Frontage mean     57.6\n#&gt; 2 Lot_Frontage var      57.6\n#&gt; 3 Lot_Area     mean  10148. \n#&gt; 4 Lot_Area     var   10148.\n\nOutras dicas\nPodemos reescrever a função across() de diversas maneiras:\n\n\nEx. 1\nEx. 2\nEx. 3\nEx. 4\n\n\n\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = c(\n                bill_length_mm, bill_depth_mm,\n                flipper_length_mm, body_mass_g\n            ),\n            .fns = \\(.x) mean(.x, na.rm = TRUE)\n        )\n    ) \n#&gt; # A tibble: 1 × 4\n#&gt;   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1           43.9          17.2              201.       4202.\n\n\n\n\n# com tidyselect helper ends_with()\n# operador lógico |\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = ends_with(\"_mm\") | ends_with(\"_g\"),\n            .fns = \\(.x) mean(.x, na.rm = TRUE)\n        )\n    ) \n#&gt; # A tibble: 1 × 4\n#&gt;   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1           43.9          17.2              201.       4202.\n\n\n\n\n# com tidyselect helper ends_with()\n# operador lógico |\n# expressão anônima reduzida ~\n\npenguins |&gt; \n    summarise(\n        across(\n            .cols = ends_with(\"_mm\") | ends_with(\"_g\"),\n            .fns = ~ mean(.x, na.rm = TRUE)\n        )\n    ) \n#&gt; # A tibble: 1 × 4\n#&gt;   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1           43.9          17.2              201.       4202.\n\n\n\n\n# com tidyselect helper ends_with()\n# operador lógico |\n# expressão anônima reduzida ~\n# parâmetros implícitos\n\npenguins |&gt; \n    summarise(across(ends_with(\"_mm\") | ends_with(\"_g\"), ~ mean(.x, na.rm = T))) \n#&gt; # A tibble: 1 × 4\n#&gt;   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1           43.9          17.2              201.       4202.\n\n\n\n\nTambém é possível utilizar o across() com mutate():\n\nmodeldata::ames |&gt; \n    mutate(across(matches(\"(Y|y)ear\"), ~ make_date(year = .x))) |&gt; \n    select(where(is.Date))\n#&gt; # A tibble: 2,930 × 3\n#&gt;   Year_Built Year_Remod_Add Year_Sold \n#&gt;   &lt;date&gt;     &lt;date&gt;         &lt;date&gt;    \n#&gt; 1 1960-01-01 1960-01-01     2010-01-01\n#&gt; 2 1961-01-01 1961-01-01     2010-01-01\n#&gt; 3 1958-01-01 1958-01-01     2010-01-01\n#&gt; 4 1968-01-01 1968-01-01     2010-01-01\n#&gt; 5 1997-01-01 1998-01-01     2010-01-01\n#&gt; 6 1998-01-01 1998-01-01     2010-01-01\n#&gt; # ℹ 2,924 more rows\n\nEste é somente um exemplo dos mais diversos de como é possível combinar across() com mutate() ou summarise() para fazer bastante progresso em uma análise de dados, digitando bem menos e otimizando consideravelmente o código."
  },
  {
    "objectID": "index.html#olá-sou-lucas-da-silva.",
    "href": "index.html#olá-sou-lucas-da-silva.",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Sou ex-intercambista pelo programa Gira Mundo. Ao retornar ao Brasil, fui contemplado com uma bolsa de estudos no CCAA, onde concluí o curso de inglês em 2020. No ano seguinte, atuei como professor de língua inglesa. Atualmente, sou graduando em Ciências Contábeis pela Universidade Federal da Paraíba.\nAo longo da graduação, participei de diversos projetos de pesquisa e extensão, nos quais desenvolvi habilidades em análise de dados utilizando a linguagem de programação R e pacotes como o Tidyverse, além de frameworks como Shiny e Quarto. Essa experiência me proporcionou uma base sólida em data science e influenciou meu interesse nas áreas de Audit & Assurance, FP&A e M&A.\nFora do ambiente acadêmico e profissional, gosto de acompanhar esportes, pedalar e jogar videogames e boardgames."
  },
  {
    "objectID": "blog/blogposts/introducao-r/index.html#instalando-o-r",
    "href": "blog/blogposts/introducao-r/index.html#instalando-o-r",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "Instalando o R",
    "text": "Instalando o R\nPara começar, você deve ter sua própria cópia do R. Felizmente, o R é totalmente gratuito e fácil de baixar. O R é gerenciado por um time de desenvolvedores que disponibilizam a linguagem no CRAN. O CRAN oferece opções de download para Windows, Mac e Linux.\n\nWindows: No site do CRAN, selecione o link de download para Windows e escolha a versão “base” do R. Baixe o instalador e execute-o. O instalador adicionará um atalho do R na sua área de trabalho.\nMac: No site do CRAN, selecione o link de download para Mac e clique no pacote da versão mais recente do R. Um instalador guiará o processo de instalação.\nLinux: O R já vem pré-instalado em diversas distribuições Linux. Caso precise da versão mais recente, o CRAN oferece arquivos para as principais distribuições. O processo de instalação varia conforme a distribuição; consulte a documentação do CRAN para instruções detalhadas.\n\nO R não é um programa que você simplesmente dá dois clicks para começar a usar, como o Microsoft Word ou Google Chrome. R é uma linguagem de programação, como Python, C, Javascript ou Rust. A maneira de usar o R é escrever comandos na linguagem R e pedir para seu computador interpretá-los. Antigamente, as pessoas executavam o código em R diretamente na linha de comando. Hoje em dia quase todo mundo usa um aplicativo para escrever código em R chamado RStudio e eu recomendo que você faça o mesmo."
  },
  {
    "objectID": "blog/blogposts/introducao-r/index.html#instalando-o-rstudio",
    "href": "blog/blogposts/introducao-r/index.html#instalando-o-rstudio",
    "title": "Iniciando no R: instalação do R e Rstudio",
    "section": "Instalando o RStudio",
    "text": "Instalando o RStudio\nAgora sim, o Rstudio é um programa como o Microsoft Word ou Google Chrome, exceto que ao invés de te ajudar a escrever em português ou navegar na internet, o RStudio te ajuda a em escrever em R e a criar scripts. Existem outros aplicativos para auxiliar o código em R, mas recomendo o RStudio pois ele faz escrever código em R (e em outras linguagens de programação, como Python) muito mais simples.\nPara instalá-lo, visite o site da Posit e baixe a versão correspondente ao seu sistema operacional. Após a instalação, abra o RStudio como qualquer outro programa.\nExplorando a Interface do RStudio\n\n\nLayout padrão do RStudio. A seta azul é onde está localizada a linha de comando.\n\nAntes de você entrar em contato com o seu computador, primeiro você deverá aprender a como falar com ele. É nessa parte que o R e o RStudio entram em cena. RStudio é a forma de como se comunicar com o seu computador. R é o idioma que você conversa com ele.\nAo abrir o RStudio, você verá uma janela com três painéis principais:\n\nConsole: Localizado geralmente na parte inferior esquerda, é onde você digita e executa comandos em R. O painel do console é exatamente o que você veria se usasse o R em linha de comando. Todo o resto é único do RStudio.\nAmbiente/Histórico: No canto superior direito, exibe as variáveis ativas e o histórico de comandos utilizados.\nArquivos/Plots/Packages/Help: Na parte inferior direita, permite navegar pelos arquivos do projeto, visualizar gráficos gerados, gerenciar pacotes instalados e acessar a documentação de ajuda.\n\nPara adicionar um quarto painel com o editor de scripts, vá em Arquivo &gt; Novo Arquivo &gt; R Script ou utilize o atalho Ctrl + Shift + N. Isso permitirá que você escreva, edite e salve seus códigos para reutilização futura.\n\n\nLayout do Rstudio com quatro painéis.\n\nPrimeiros Passos no R\nA interface do RStudio é simples. Você escreve seu código em R na última linha do painel do Console no RStudio e pressiona Enter para executar. O código que você escreve é chamado de comando, pois você está dando uma ordem ao computador para fazer algo para você. A linha em que você escreve o comando é chamada de linha de comando.\nQuando você digita um comando na linha de comando e pressiona Enter, seu computador executa o comando e mostra os resultados. Por exemplo, se você digitar 1 + 1 e pressionar Enter, o RStudio vai mostrar o seguinte:\n\n1 + 1\n#&gt; [1] 2\n\nPara criar um objeto (variável) que armazene um valor, utilize o operador &lt;-:\n\nminha_variavel &lt;- 10\n\nAgora, minha_variavel contém o valor 10. Você pode usar esse objeto em operações futuras:\n\nminha_variavel * 2\n#&gt; [1] 20\n\nÀ medida que avança, você explorará funções mais complexas e pacotes adicionais que expandem as capacidades do R. Uma coleção essencial de pacotes para ciência de dados é o tidyverse, que inclui ferramentas para manipulação de dados, visualização e muito mais. Para conhecer mais sobre o universo do tidyverse, clique neste blogpost."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html",
    "title": "Gerenciando dependências com {renv}",
    "section": "",
    "text": "Se você já passou pela frustração de tentar rodar um código R antigo e descobrir que ele não funciona mais devido a mudanças nas versões dos pacotes, você não está sozinho. Esse é um problema comum, e é exatamente para isso que o pacote renv foi criado."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#o-que-é-o-renv",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#o-que-é-o-renv",
    "title": "Gerenciando Dependências com {renv}",
    "section": "O que é o renv?",
    "text": "O que é o renv?\nO renv é um pacote que facilita o gerenciamento de ambientes no R, permitindo que cada projeto tenha suas próprias versões específicas de pacotes. Isso evita conflitos e problemas causados por atualizações inesperadas.\nCom o renv, você pode: - Criar um ambiente isolado para cada projeto. - Instalar pacotes específicos para esse ambiente. - Salvar um snapshot do estado atual dos pacotes. - Restaurar os pacotes a qualquer momento."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#instalando-e-inicializando-o-renv",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#instalando-e-inicializando-o-renv",
    "title": "Gerenciando Dependências com {renv}",
    "section": "Instalando e inicializando o renv",
    "text": "Instalando e inicializando o renv\nPara começar a usar o renv, instale o pacote e inicialize o ambiente no seu projeto:\ninstall.packages(\"renv\")\nlibrary(renv)\nrenv::init()\nIsso cria um ambiente renv no diretório do seu projeto e gera um arquivo de bloqueio (renv.lock), onde ficam registradas as versões dos pacotes utilizados."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#instalando-pacotes-dentro-do-renv",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#instalando-pacotes-dentro-do-renv",
    "title": "Gerenciando dependências com {renv}",
    "section": "Instalando pacotes dentro do renv",
    "text": "Instalando pacotes dentro do renv\nAo trabalhar com um projeto gerenciado pelo renv, você deve instalar os pacotes usando a função renv::install(), em vez de install.packages():\n\nrenv::install(\"lubridate\")\nlibrary(lubridate)\n\nIsso garante que o pacote lubridate seja instalado apenas no ambiente do projeto, sem interferir nos pacotes globais do R."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#criando-um-snapshot",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#criando-um-snapshot",
    "title": "Gerenciando dependências com {renv}",
    "section": "Criando um snapshot",
    "text": "Criando um snapshot\nSempre que adicionar ou atualizar pacotes, é importante capturar um snapshot do estado atual do ambiente, garantindo que todas as dependências estejam documentadas no arquivo renv.lock:\n\nrenv::snapshot()\n\nSe você compartilhar esse arquivo com colegas ou versioná-lo no Git, qualquer pessoa poderá restaurar as mesmas versões dos pacotes."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#restaurando-pacotes",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#restaurando-pacotes",
    "title": "Gerenciando dependências com {renv}",
    "section": "Restaurando pacotes",
    "text": "Restaurando pacotes\nSe precisar recuperar as versões exatas dos pacotes de um projeto, basta rodar:\n\nrenv::restore()\n\nIsso reinstala todas as dependências conforme especificadas no arquivo renv.lock, garantindo a reprodutibilidade do seu código."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#verificando-o-status-do-ambiente",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#verificando-o-status-do-ambiente",
    "title": "Gerenciando dependências com {renv}",
    "section": "Verificando o status do ambiente",
    "text": "Verificando o status do ambiente\nPara conferir se o ambiente está sincronizado e identificar pacotes não documentados, use:\n\nrenv::status()\n\nSe houver pacotes instalados que ainda não foram registrados no snapshot, essa função ajudará a identificá-los."
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#conclusão",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#conclusão",
    "title": "Gerenciando Dependências com {renv}",
    "section": "Conclusão",
    "text": "Conclusão\nO renv é uma ferramenta essencial para quem trabalha com R, especialmente em projetos de longo prazo ou colaborativos. Ele garante que seu código permaneça funcional independentemente das atualizações dos pacotes, trazendo maior segurança e previsibilidade ao desenvolvimento.\nAdote o renv nos seus projetos e evite dores de cabeça com versões incompatíveis!\n\nGostou deste guia? Compartilhe com outros desenvolvedores e garanta que seus projetos em R sejam sempre reprodutíveis!"
  },
  {
    "objectID": "blog/blogposts/gerenciando-dependencias-renv/index.html#principais-funções-do-renv",
    "href": "blog/blogposts/gerenciando-dependencias-renv/index.html#principais-funções-do-renv",
    "title": "Gerenciando dependências com {renv}",
    "section": "Principais funções do renv",
    "text": "Principais funções do renv\nTudo isso pode soar complicado, mas no fim das contas, tudo que devemos saber são meras quatro funções:\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\nrenv::init()\nInicializa o ambiente renv\n\n\nrenv::install()\nInstala os pacotes no ambiente renv\n\n\nrenv::snapshot()\nDocumenta as versões dos pacotes\n\n\nrenv::restore()\nRestora versões dos pacotes"
  },
  {
    "objectID": "blog/blogposts/limpeza-dados-janitor/index.html",
    "href": "blog/blogposts/limpeza-dados-janitor/index.html",
    "title": "Limpando dados com {janitor}",
    "section": "",
    "text": "O pacote janitor possui um grande número de funções feitas para faciliar nosso trabalho de limpeza de dados. Vamos explorar algumas das funcionalidades mais úteis deste pacote."
  },
  {
    "objectID": "blog/blogposts/limpeza-dados-janitor/index.html#pulando-linhas-e-limpando-nomes",
    "href": "blog/blogposts/limpeza-dados-janitor/index.html#pulando-linhas-e-limpando-nomes",
    "title": "Limpando dados com {janitor}",
    "section": "Pulando linhas e limpando nomes",
    "text": "Pulando linhas e limpando nomes\nAo importar esta planilha, logo percebemos que os nomes das colunas ficam um caos:\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\")\n#&gt; New names:\n#&gt; • `` -&gt; `...2`\n#&gt; • `` -&gt; `...3`\n#&gt; • `` -&gt; `...5`\n#&gt; • `` -&gt; `...6`\n#&gt; • `` -&gt; `...7`\n#&gt; • `` -&gt; `...8`\n#&gt; • `` -&gt; `...9`\n#&gt; • `` -&gt; `...10`\n#&gt; • `` -&gt; `...11`\ndirty_data\n#&gt; # A tibble: 14 × 11\n#&gt;   Data most recently refr…¹ ...2      ...3            `Dec-27 2020` ...5     \n#&gt;   &lt;chr&gt;                     &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;         &lt;chr&gt;    \n#&gt; 1 First Name                Last Name Employee Status Subject       Hire Date\n#&gt; 2 Jason                     Bourne    Teacher         PE            39690    \n#&gt; 3 Jason                     Bourne    Teacher         Drafting      43479    \n#&gt; 4 Alicia                    Keys      Teacher         Music         37118    \n#&gt; 5 Ada                       Lovelace  Teacher         &lt;NA&gt;          38572    \n#&gt; 6 Desus                     Nice      Administration  Dean          42791    \n#&gt; # ℹ 8 more rows\n#&gt; # ℹ abbreviated name: ¹​`Data most recently refreshed on:`\n\nIsso se deve devido a primeira linha do arquivo excel possuir um título (header). Podemos resolver isto apenas pulando a primeira linha com o parâmetro skip do read_excel():\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\", skip = 1)\ndirty_data\n#&gt; # A tibble: 13 × 11\n#&gt;   `First Name` `Last Name` `Employee Status` Subject  `Hire Date`\n#&gt;   &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;             &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Jason        Bourne      Teacher           PE             39690\n#&gt; 2 Jason        Bourne      Teacher           Drafting       43479\n#&gt; 3 Alicia       Keys        Teacher           Music          37118\n#&gt; 4 Ada          Lovelace    Teacher           &lt;NA&gt;           38572\n#&gt; 5 Desus        Nice        Administration    Dean           42791\n#&gt; 6 Chien-Shiung Wu          Teacher           Physics        11037\n#&gt; # ℹ 7 more rows\n#&gt; # ℹ 6 more variables: `% Allocated` &lt;dbl&gt;, `Full time?` &lt;chr&gt;, …\n\nDesta forma temos melhores nomes para as variáveis, mas eles ainda não são ideais para trabalhar. Para lidar com isso, podemos usufruir de um pouco da mágica do janitor com a função clean_names():\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\", skip = 1)\n\ndirty_data |&gt; \n  clean_names()\n#&gt; # A tibble: 13 × 11\n#&gt;   first_name   last_name employee_status subject  hire_date percent_allocated\n#&gt;   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Jason        Bourne    Teacher         PE           39690              0.75\n#&gt; 2 Jason        Bourne    Teacher         Drafting     43479              0.25\n#&gt; 3 Alicia       Keys      Teacher         Music        37118              1   \n#&gt; 4 Ada          Lovelace  Teacher         &lt;NA&gt;         38572              1   \n#&gt; 5 Desus        Nice      Administration  Dean         42791              1   \n#&gt; 6 Chien-Shiung Wu        Teacher         Physics      11037              0.5 \n#&gt; # ℹ 7 more rows\n#&gt; # ℹ 5 more variables: full_time &lt;chr&gt;, do_not_edit &lt;lgl&gt;, …\n\nÓtimo! nosso data.frame está tomando forma com apenas um parâmetro e uma função. Porém, se lembrarmos bem, ainda há colunas vazias, linhas vazias e colunas com valores constantes."
  },
  {
    "objectID": "blog/blogposts/limpeza-dados-janitor/index.html#removendo-observações-vazias-variáveis-vazias-e-valores-constantes",
    "href": "blog/blogposts/limpeza-dados-janitor/index.html#removendo-observações-vazias-variáveis-vazias-e-valores-constantes",
    "title": "Limpando dados com {janitor}",
    "section": "Removendo observações vazias, variáveis vazias e valores constantes",
    "text": "Removendo observações vazias, variáveis vazias e valores constantes\nPara lidar com observações ou variáveis vazias, o janitor nos dá a função remove_empty():\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\", skip = 1)\n\ndirty_data |&gt; \n  clean_names() |&gt; \n  remove_empty()\n#&gt; # A tibble: 12 × 10\n#&gt;   first_name   last_name employee_status subject  hire_date percent_allocated\n#&gt;   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Jason        Bourne    Teacher         PE           39690              0.75\n#&gt; 2 Jason        Bourne    Teacher         Drafting     43479              0.25\n#&gt; 3 Alicia       Keys      Teacher         Music        37118              1   \n#&gt; 4 Ada          Lovelace  Teacher         &lt;NA&gt;         38572              1   \n#&gt; 5 Desus        Nice      Administration  Dean         42791              1   \n#&gt; 6 Chien-Shiung Wu        Teacher         Physics      11037              0.5 \n#&gt; # ℹ 6 more rows\n#&gt; # ℹ 4 more variables: full_time &lt;chr&gt;, certification_9 &lt;chr&gt;, …\n\nNote que a tibble deixou de ter 13 observações e 11 variáveis para 12 observações e 10 variáveis.\nJá a coluna “Active” na nossa planilha possui apenas um valor constante, “YES”, efetivamente não possuindo nenhuma informação relevante para nós. Para estes casos, janitor oferece remove_constant():\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\", skip = 1)\n\ndirty_data |&gt; \n  clean_names() |&gt; \n  remove_empty() |&gt; \n  remove_constant()\n#&gt; # A tibble: 12 × 9\n#&gt;   first_name   last_name employee_status subject  hire_date percent_allocated\n#&gt;   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Jason        Bourne    Teacher         PE           39690              0.75\n#&gt; 2 Jason        Bourne    Teacher         Drafting     43479              0.25\n#&gt; 3 Alicia       Keys      Teacher         Music        37118              1   \n#&gt; 4 Ada          Lovelace  Teacher         &lt;NA&gt;         38572              1   \n#&gt; 5 Desus        Nice      Administration  Dean         42791              1   \n#&gt; 6 Chien-Shiung Wu        Teacher         Physics      11037              0.5 \n#&gt; # ℹ 6 more rows\n#&gt; # ℹ 3 more variables: full_time &lt;chr&gt;, certification_9 &lt;chr&gt;, …"
  },
  {
    "objectID": "blog/blogposts/limpeza-dados-janitor/index.html#tratando-datas",
    "href": "blog/blogposts/limpeza-dados-janitor/index.html#tratando-datas",
    "title": "Limpando dados com {janitor}",
    "section": "Tratando datas",
    "text": "Tratando datas\nPara lidar com problemas de formatação de datas do Excel, podemos usar a função excel_numeric_to_date() para a coluna “hire_date”\n\ndirty_data &lt;- read_excel(\"data/dirty_data.xlsx\", skip = 1)\n\ndirty_data |&gt; \n  clean_names() |&gt; \n  remove_empty() |&gt; \n  remove_constant() |&gt; \n  mutate(hire_date = excel_numeric_to_date(hire_date))\n#&gt; # A tibble: 12 × 9\n#&gt;   first_name   last_name employee_status subject  hire_date \n#&gt;   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;    &lt;date&gt;    \n#&gt; 1 Jason        Bourne    Teacher         PE       2008-08-30\n#&gt; 2 Jason        Bourne    Teacher         Drafting 2019-01-14\n#&gt; 3 Alicia       Keys      Teacher         Music    2001-08-15\n#&gt; 4 Ada          Lovelace  Teacher         &lt;NA&gt;     2005-08-08\n#&gt; 5 Desus        Nice      Administration  Dean     2017-02-25\n#&gt; 6 Chien-Shiung Wu        Teacher         Physics  1930-03-20\n#&gt; # ℹ 6 more rows\n#&gt; # ℹ 4 more variables: percent_allocated &lt;dbl&gt;, full_time &lt;chr&gt;, …\n\nAgora sim! Se notarmos a coluna “hire_date”, podemos ver que as datas estão todas lá, em formato &lt;date&gt; que podemos trabalhar. E desta forma, temos uma tibble que está pronta para o processamento dos dados com qualquer fim!"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Dashboard - Analisando Fraudes com a Lei de Benford\n\n\nFerramenta analítica para processos de auditoria, utilizando técnicas estatísticas e visualização de dados para identificar anomalias em transações financeiras.\n\n\n\n\n\n\n20 de abr. de 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nDashboard - IndicadoresB3\n\n\nDashboard que transforma dados financeiros públicos em insights através de uma interface interativa.\n\n\n\n\n\n\n30 de jan. de 2025\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html",
    "href": "projects/projects_list/IndB3/index.html",
    "title": "Dashboard - IndicadoresB3",
    "section": "",
    "text": "Acessar Dashboard  Sobre  Metodologia  Código-Fonte"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#intro",
    "href": "projects/projects_list/IndB3/index.html#intro",
    "title": "Fraud Analytics with Benford’s Law",
    "section": "Intro",
    "text": "Intro\nThis link should appear as a button:\nConclusion\nConclusion"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#sec-conclusion",
    "href": "projects/projects_list/IndB3/index.html#sec-conclusion",
    "title": "Fraud Analytics with Benford’s Law",
    "section": "Conclusion",
    "text": "Conclusion\nSome text."
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#sobre-este-projeto",
    "href": "projects/projects_list/IndB3/index.html#sobre-este-projeto",
    "title": "Dashboard - IndicadoresB3",
    "section": "Sobre Este Projeto",
    "text": "Sobre Este Projeto\nUtilizando dados abertos da Comissão de Valores Mobiliários (CVM), o IndicadoresB3 foi desenvolvido para demonstrar uma aplicação prática de técnicas de ciência de dados à análise financeira. Ele apresenta:\n\nHabilidades Técnicas: Programação em R, ciência de dados aplicada aos dados financeiros, visualização de dados\nConhecimento Financeiro: Análise de demonstrações contábeis, indicadores financeiros, avaliação de desempenho empresarial\nConhecimento de Negócios: Interpretação contextual de métricas financeiras por setor e segmento\n\n\nProcesso de Desenvolvimento\n\nColeta de Dados: Importação automática de demonstrações financeiras do portal de dados abertos da CVM\nProcessamento e Limpeza: Transformação e normalização dos dados contábeis para análise\nModelagem: Cálculo de indicadores financeiros relevantes e métricas comparativas\nDesenvolvimento do Dashboard: Criação de visualizações interativas usando Shiny, bs4Dash e Echarts4r\nDocumentação: Fornecimento de explicações metodológicas e guias de usuário\n\n\n\nExtensões Potenciais\n\nAnálises preditivas de desempenho financeiro\nComparação de indicadores com médias setoriais\nAlertas para variações significativas em métricas-chave\nFuncionalidades de exportação de relatórios customizados"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#metodologia",
    "href": "projects/projects_list/IndB3/index.html#metodologia",
    "title": "Dashboard - IndicadoresB3",
    "section": "Metodologia",
    "text": "Metodologia\nEste dashboard emprega três componentes principais para análise financeira:\n\n1. Análise de Demonstrações Financeiras\nO dashboard apresenta dados dos principais relatórios contábeis:\n\nDemonstração de Resultado (DR): Análise da receita, custos, despesas e resultados operacionais\nBalanço Patrimonial - Ativo (BPA): Análise da estrutura de ativos da empresa\nBalanço Patrimonial - Passivo (BPP): Análise da estrutura de capital e endividamento\n\nPara cada demonstração financeira, são exibidos dados de até 5 anos (2020-2024), permitindo a análise de tendências e variações percentuais entre períodos.\n\n\n2. Indicadores de Rentabilidade\nSão calculados indicadores como:\n\nRetorno sobre Patrimônio Líquido (ROE): Mede a rentabilidade gerada em relação ao capital próprio investido\n\n\\[\nROE = \\frac{\\text{Lucro Líquido}}{\\text{Patrimônio Líquido}}\n\\]\nEste indicador é fundamental para avaliar a eficiência da empresa na geração de lucros a partir do capital dos acionistas.\n\n\n3. Análise de Liquidez\nO dashboard calcula e visualiza três indicadores de liquidez fundamentais:\n\nLiquidez Corrente (LC): Capacidade de pagamento de obrigações de curto prazo\n\\[\nLC = \\frac{\\text{Ativo Circulante}}{\\text{Passivo Circulante}}\n\\]\nLiquidez Seca (LS): Capacidade de pagamento excluindo estoques\n\\[\nLS = \\frac{\\text{Ativo Circulante} - \\text{Estoques}}{\\text{Passivo Circulante}}\n\\]\nLiquidez Imediata (LI): Capacidade de pagamento utilizando apenas recursos de alta liquidez\n\\[\nLI = \\frac{\\text{Disponibilidades}}{\\text{Passivo Circulante}}\n\\]"
  },
  {
    "objectID": "projects/projects_list/Benford/index.html",
    "href": "projects/projects_list/Benford/index.html",
    "title": "Dashboard - Analisando Fraudes com a Lei de Benford",
    "section": "",
    "text": "Acessar Dashboard  Sobre  Metodologia  Código-Fonte\nA Lei de Benford, um dos pilares metodológicos deste dashboard, é um fenômeno estatístico que postula que em muitas coleções naturais de dados numéricos, a distribuição dos primeiros dígitos não é uniforme. Pelo contrário, o dígito 1 aparece como primeiro dígito em aproximadamente 30% dos números, enquanto dígitos maiores ocorrem com frequência progressivamente menor. Esta lei matemática tem aplicações poderosas na detecção de fraudes, pois dados manipulados ou fabricados tendem a não seguir este padrão natural de distribuição, permitindo aos auditores identificar conjuntos de dados que merecem investigação mais aprofundada."
  },
  {
    "objectID": "projects/projects_list/Benford/index.html#sobre-este-projeto",
    "href": "projects/projects_list/Benford/index.html#sobre-este-projeto",
    "title": "Dashboard - Analisando Fraudes com a Lei de Benford",
    "section": "Sobre Este Projeto",
    "text": "Sobre Este Projeto\nUtilizando a Lei de Benford, este Dashboard Analítico de Auditoria foi desenvolvido para demonstrar uma aplicação prática de técnicas de ciência de dados à auditoria. Ele apresenta:\n\nHabilidades Técnicas: Programação em R, análise estatística, ciência de dados, visualização de dados\nConhecimento de Auditoria: Aplicação de técnicas de auditoria aceitas como a Lei de Benford\nConhecimento de Negócios: Interpretação de anomalias financeiras no contexto empresarial\n\n\nProcesso de Desenvolvimento\n\nAnálise de Requisitos: Identificação de preocupações-chave de auditoria e abordagens analíticas\nModelagem de Dados: Estruturas de dados projetadas para suportar a detecção de anomalias\nDesenvolvimento do Dashboard: Criação de visualizações interativas usando Shiny e Echarts\nDocumentação: Fornecimento de explicações metodológicas claras e guias de usuário\n\n\n\nExtensões Potenciais\n\nIntegração com sistemas de monitoramento contínuo\nModelos de Machine Learning para detecção de anomalias mais sofisticada\nIncorporação de fatores de risco específicos do setor\nFuncionalidades de relatórios automatizados"
  },
  {
    "objectID": "projects/projects_list/Benford/index.html#metodologia",
    "href": "projects/projects_list/Benford/index.html#metodologia",
    "title": "Dashboard - Analisando Fraudes com a Lei de Benford",
    "section": "Metodologia",
    "text": "Metodologia\nEste dashboard emprega três técnicas principais para detecção de anomalias em dados financeiros:\n\n1. Análise da Lei de Benford\nA Lei de Benford afirma que em muitos conjuntos de dados numéricos de ocorrência natural, os primeiros dígitos seguem uma distribuição específica, com 1 aparecendo como primeiro dígito em cerca de 30% das vezes. Dados financeiros que se desviam significativamente desse padrão podem justificar uma investigação mais aprofundada.\nFoi utilizado o pacote benford.analysis do R para realizar testes estatísticos na distribuição do primeiro dígito:\n\nTeste qui-quadrado para medir o ajuste geral\nDesvio Médio Absoluto (DMA) para quantificar o desvio das frequências esperadas\n\n\n\n2. Análise de Z-Score\nOs Z-scores medem quantos desvios padrão um ponto de dados está da média. Calculamos z-scores para cada valor de transação dentro do contexto de sua conta:\n\\[\nZ = \\frac{X - \\mu}{\\sigma}\n\\]\nOnde:\n\nX é o valor da transação\nμ é o valor médio da transação para aquela conta\nσ é o desvio padrão dos valores de transação para aquela conta\n\nQuanto maior o valor absoluto do z-score, mais incomum a transação é:\n\nZ-score próximo de 0: Quantia da transação é próxima da média\nZ-score &gt; 2.5: A transação é classificada com outlier\nZ-score &gt; 3: A transação é altamente incomum\nZ-score positivos indicam quantidades acima da média\nZ-scores negativos indicam quantidades abaixo da média\n\n\n\n3. Análise de Séries Temporais\nO dashboard visualiza volumes e valores de transações ao longo do tempo para identificar padrões incomuns ou picos que possam indicar períodos problemáticos que requerem exame mais detalhado."
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#interface-do-dashboard",
    "href": "projects/projects_list/IndB3/index.html#interface-do-dashboard",
    "title": "Dashboard - IndicadoresB3",
    "section": "Interface do Dashboard",
    "text": "Interface do Dashboard\nO dashboard é composto por três abas principais:\n\nDashboard: Visão geral do desempenho financeiro, incluindo:\n\nInformações cadastrais da empresa\nReceita e resultado do último período\nEvolução trimestral da receita\nAnálise de margens (bruta e líquida)\nComparativo entre receita e resultado ao longo do tempo\n\nIndicadores: Análise de indicadores financeiros:\n\nEvolução do ROE ao longo do tempo\nIndicadores de liquidez (corrente, seca e imediata)\n\nDemonstrações: Visualização detalhada das demonstrações financeiras:\n\nDemonstação do Resultado completa com análise de variação percentual entre períodos\nBalanço Patrimonial - Ativo com análise de variação\nBalanço Patrimonial - Passivo com análise de variação"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#uso-do-dashboard",
    "href": "projects/projects_list/IndB3/index.html#uso-do-dashboard",
    "title": "Dashboard - IndicadoresB3",
    "section": "Uso do Dashboard",
    "text": "Uso do Dashboard\n\nSelecione a empresa desejada no menu lateral\nNavegue entre as abas para analisar diferentes aspectos financeiros\nInteraja com os gráficos para visualizar informações detalhadas"
  },
  {
    "objectID": "projects/projects_list/IndB3/index.html#considerações-técnicas",
    "href": "projects/projects_list/IndB3/index.html#considerações-técnicas",
    "title": "Dashboard - IndicadoresB3",
    "section": "Considerações Técnicas",
    "text": "Considerações Técnicas\nO projeto utiliza diversas bibliotecas R para processamento e visualização:\n\ntidyverse: Para importação, limpeza e transformação de dados\nshiny e bs4Dash: Para a interface interativa\necharts4r: Para visualizações gráficas dinâmicas\nreactable: Para tabelas interativas responsivas\n\nOs dados financeiros são processados seguindo as práticas contábeis padrozinadas, com ajustes para garantir a comparabilidade entre diferentes empresas e períodos."
  }
]