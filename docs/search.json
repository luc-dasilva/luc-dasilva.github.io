[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Oi! Sou Lucas da Silva, fui intercambista pelo programa Gira Mundo em 2018. Após retornar ao Brasil consegui uma bolsa de estudos na escola de idiomas CCAA, onde conclui o curso de língua inglesa em 2020. Fui professor de língua inglesa em 2021. Atualmente sou graduando em Ciências Contábeis pela Universidade Federal da Paraíba.\nDurante a graduação consegui me engajar em diversos projetos de pesquisa e em um deles conheci a linguagem de programação R, as coleções de pacotes Tidyverse, Tidyquant e Tidymodels, além dos frameworks Shiny e Quarto. Desde então, venho adquirindo experiência com estas ferramentas e em data literacy.\nFora dos estudos, eu gosto muito de acompanhar esportes, de andar de bicicleta e dos meus gatos."
  },
  {
    "objectID": "index.html#formação",
    "href": "index.html#formação",
    "title": "Lucas da Silva",
    "section": "Formação",
    "text": "Formação\n\nUniversidade Federal da Paraíba | Graduação em Ciências Contábeis | Desde 2020\nEscola de Idiomas CCAA | Curso de Língua Inglesa | Jul 2019 - Ago 2020\nWalkerton District Community School | Intercâmbio | Set 2018 - Fev 2019"
  },
  {
    "objectID": "proj1.html",
    "href": "proj1.html",
    "title": "Test 1",
    "section": "",
    "text": "This is a test."
  },
  {
    "objectID": "blog/blogpost1.html",
    "href": "blog/blogpost1.html",
    "title": "Blog Template",
    "section": "",
    "text": "This is the first post in my blog!\nNote that all blog posts are frozen, i.e., when we render the entire site the computations are not re-run, but rather read from the previously frozen results\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/blogpost1.html#subsection-header",
    "href": "blog/blogpost1.html#subsection-header",
    "title": "Blog Template",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Blog Template\n\n\n\n\n\nThis is a blog template\n\n\n\n\n\n20 de jan. de 2023\n\n\nLucas\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Lucas da Silva",
    "section": "",
    "text": "Importação de Planilhas do Excel no R\n\n\nDados do Excel ao R de maneira fácil e rápida.\n\n\n\nLucas da Silva\n\n\n7 de ago. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUma breve introdução ao Tidyverse\n\n\nUm resumo do essencial para iniciar no mundo do Tidyverse.\n\n\n\nLucas da Silva\n\n\n5 de ago. de 2024\n\n\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "blog/blogposts/blogpost1.html",
    "href": "blog/blogposts/blogpost1.html",
    "title": "Blog Template",
    "section": "",
    "text": "This is the first post in my blog!\nNote that all blog posts are frozen, i.e., when we render the entire site the computations are not re-run, but rather read from the previously frozen results\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/blogposts/blogpost1.html#subsection-header",
    "href": "blog/blogposts/blogpost1.html#subsection-header",
    "title": "Blog Template",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog/blogposts/test/index.html",
    "href": "blog/blogposts/test/index.html",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "",
    "text": "O tidyverse, uma coleção de pacotes focados em ciência de dados, é um dos principais atrativos da linguagem de programação R. Nesta postagem serão sintetizados os principais aspectos necessários para o início da jornada na ciência de dados com o tidyverse."
  },
  {
    "objectID": "blog/blogposts/test/index.html#subsection-header",
    "href": "blog/blogposts/test/index.html#subsection-header",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Subsection Header",
    "text": "Subsection Header\nH2 headers will appear as sub-level navigation items on the right.\n\nSubsubsection Header\nH3 headers will be ignored for the navigation."
  },
  {
    "objectID": "blog/blogposts/test/index.html#ler-e-escrever-dados",
    "href": "blog/blogposts/test/index.html#ler-e-escrever-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Ler e escrever dados",
    "text": "Ler e escrever dados\nO pacote readr facilita escrever ou ler os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, vamos importar dados de mobilidade registrados pela Google durante a pandemia de COVID-19.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv( ) ou read_csv2( )\nimporta dados csv (vírgula ou ponto e vírgula)\n\n\nread_delim( )\nseparador geral\n\n\nread_table( )\nseparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\ngoogle_mobility &lt;- read_csv(\"Global_Mobility_Report.csv\")\n\nRows: 516697 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (6): country_region_code, country_region, sub_region_1, sub_region_2, i...\ndbl  (6): retail_and_recreation_percent_change_from_baseline, grocery_and_ph...\ndate (1): date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ngoogle_mobility\n\n# A tibble: 516,697 × 13\n   country_region_code country_region  sub_region_1 sub_region_2 iso_3166_2_code\n   &lt;chr&gt;               &lt;chr&gt;           &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;          \n 1 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 2 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 3 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 4 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 5 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 6 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 7 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 8 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n 9 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n10 AE                  United Arab Em… &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;           \n# ℹ 516,687 more rows\n# ℹ 8 more variables: census_fips_code &lt;chr&gt;, date &lt;date&gt;,\n#   retail_and_recreation_percent_change_from_baseline &lt;dbl&gt;,\n#   grocery_and_pharmacy_percent_change_from_baseline &lt;dbl&gt;,\n#   parks_percent_change_from_baseline &lt;dbl&gt;,\n#   transit_stations_percent_change_from_baseline &lt;dbl&gt;,\n#   workplaces_percent_change_from_baseline &lt;dbl&gt;, …\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#transformação-de-caracteres",
    "href": "blog/blogposts/test/index.html#transformação-de-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de caracteres",
    "text": "Transformação de caracteres\nPara trabalhar com caracteres (a.k.a. strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nstr_replace\nSubstitui padrões\n\n\nstr_c\nCombine caracteres\n\n\nstr_detect\nDetecta padrões\n\n\nstr_extract\nExtrai padrões\n\n\nstr_sub\nExtrai por posição\n\n\nstr_length\nTamanho de uma string\n\n\n\nÉ comum o uso de expressões regulares para detecção de padrões. Mais detalhes sobre as funções e expressões regulares podem ser entrontados cheat-sheet do stringr.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\n\n# substituir 'er' com espaço vazio\nstr_replace(month.name, \"ber$\", \"\")\n\n [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"   \n\n\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n\n [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n[11] \"November_11\" \"December_12\"\n\n\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n\n[1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n\n\n# detectar padrão\nstr_detect(month.name, \"^A\")\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n# extrair padrão\nstr_extract(month.name, \"ber$\")\n\n [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, 1, 2)\n\n [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n\n\n# tamanho da string de cada mês\nstr_length(month.name)\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8"
  },
  {
    "objectID": "blog/blogposts/test/index.html#gerenciamento-de-dados-e-horas",
    "href": "blog/blogposts/test/index.html#gerenciamento-de-dados-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de dados e horas",
    "text": "Gerenciamento de dados e horas"
  },
  {
    "objectID": "blog/blogposts/test/index.html#gerenciamento-de-datas-e-horas",
    "href": "blog/blogposts/test/index.html#gerenciamento-de-datas-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de datas e horas",
    "text": "Gerenciamento de datas e horas\nO pacote lubridate é excelente para lidar com datas e horas. Apenas devemos conhecer as seguintes abreviações:\n\nymd signfica y:year (ano), m:month (mês), d:day (dia)\nhms signfica h:hour (hora), m:minutes (minutos), s:seconds (segundos)\n\n\n# vetor com datas\ndatas &lt;- c(\"2020/12/31\", \"2012/05/04\", \"2003/09/24\",\"2017/11/24\")\n\n# vetor com datas e horas\ndatas_horas &lt;- c(\"1973-08-11 02:00\", \"2009-06-13 20:00\")\n\ndatas &lt;- ymd(datas)\ndatas\n\n[1] \"2020-12-31\" \"2012-05-04\" \"2003-09-24\" \"2017-11-24\"\n\n\n\ndmy(\"13-08-2002\")\n\n[1] \"2002-08-13\"\n\nymd(\"20020813\")\n\n[1] \"2002-08-13\"\n\n\n\n# extrair o ano\nyear(datas)\n\n[1] 2020 2012 2003 2017\n\n\n\n# extrair o mês\nmonth(datas)\n\n[1] 12  5  9 11\n\n\n\n# extrair o dia da semana\nwday(datas)\n\n[1] 5 6 4 6\n\n\n\n# extrair a hora\nhour(datas_horas)\n\n[1]  2 20\n\n\n\n# adiciona 10 dias\ndatas + days(10)\n\n[1] \"2021-01-10\" \"2012-05-14\" \"2003-10-04\" \"2017-12-04\"\n\n\n\n# adiciona 1 mês\ndatas + month(1)\n\n[1] \"2021-01-01\" \"2012-05-05\" \"2003-09-25\" \"2017-11-25\"\n\n\nPara mais detalhes, veja o cheat-sheet do lubridate."
  },
  {
    "objectID": "blog/blogposts/test/index.html#importar-e-salvar-dados",
    "href": "blog/blogposts/test/index.html#importar-e-salvar-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importar e salvar dados",
    "text": "Importar e salvar dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos os dados Palmer Penguins, dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv() ou read_csv2( )\nImporta .CSV (vírgula ou ponto e vírgula)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# Assinala o arquivo penguins.csv, que está na pasta \"data\", ao objeto \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Inspeciona o conteúdo do objeto \"penguins\"\npenguins\n\n# A tibble: 344 × 9\n   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1     1 Adelie  Torgersen           39.1          18.7               181\n 2     2 Adelie  Torgersen           39.5          17.4               186\n 3     3 Adelie  Torgersen           40.3          18                 195\n 4     4 Adelie  Torgersen           NA            NA                  NA\n 5     5 Adelie  Torgersen           36.7          19.3               193\n 6     6 Adelie  Torgersen           39.3          20.6               190\n 7     7 Adelie  Torgersen           38.9          17.8               181\n 8     8 Adelie  Torgersen           39.2          19.6               195\n 9     9 Adelie  Torgersen           34.1          18.1               193\n10    10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#trabalhando-com-caracteres",
    "href": "blog/blogposts/test/index.html#trabalhando-com-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Trabalhando com caracteres",
    "text": "Trabalhando com caracteres\nPara trabalhar com caracteres (strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\n\nFunção\nDescrição\n\n\n\n\nstr_replace()\nSubstitui padrões\n\n\nstr_c()\nCombina caracteres\n\n\nstr_detect()\nDetecta padrões\n\n\nstr_extract()\nExtrai padrões\n\n\nstr_sub()\nExtrai por posição\n\n\nstr_length()\nRetorna o tamanho de uma string\n\n\n\nÉ comum o uso de expressões regulares (regex) para detecção de padrões. Abaixo temos alguns exemplos de funções do stringr em ação em conjunto com o uso de regex.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\n\n# substituir 'er' com espaço vazio\nstr_replace(month.name, \"ber$\", \"\")\n\n [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"   \n\n\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n\n [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n[11] \"November_11\" \"December_12\"\n\n\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n\n[1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n\n\n# detectar padrão\nstr_detect(month.name, \"^A\")\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n# extrair padrão\nstr_extract(month.name, \"ber$\")\n\n [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, 1, 2)\n\n [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n\n\n# tamanho da string de cada mês\nstr_length(month.name)\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8\n\n\nMais detalhes sobre as funções e expressões regulares podem ser encontrados no cheat-sheet do stringr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#transformação-de-tabelas",
    "href": "blog/blogposts/test/index.html#transformação-de-tabelas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de tabelas",
    "text": "Transformação de tabelas\nOs pacotes dplyr e tidyr oferecem gramática para a transformação de dados, ou seja, um conjunto de verbos úteis para resolver problemas. As funções mais importantes são:\n\n\n\nFunção\nDescrição\n\n\n\n\nmutate()\nAdiciona ou modifica variáveis\n\n\nselect()\nSeleciona variábeis\n\n\nfilter()\nAplica filtro\n\n\nsummarise()\nReduz variáveis\n\n\nrename()\nRenomeia colunaas\n\n\n\n\nselect() e rename()\nConseguimos selecionar ou remover colunas com a função select(), usando o nome ou índice da coluna. Para deletar colunas apenas usamos o ponto de exclamação antes do nome ou índice da coluna. A função rename()renomeia colunas da mesma forma, usando o nome ou índice da coluna.\n\n# Assinala o resultado da cadeia ao objeto \"penguins_2\" \npenguins_2 &lt;- penguins |&gt; \n    # Seleciona a coluna \"rowid\".\n    # O ponto de exclamação indica a remoção da coluna \"rowid\"\n    select(!rowid) |&gt; \n    # Renomeia a coluna \"species\" como \"penguin_species\"\n    rename(penguin_species = species)\n\n# Visualizando o novo objeto\npenguins_2\n\n# A tibble: 344 × 8\n   penguin_species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Torgersen           39.1          18.7               181\n 2 Adelie          Torgersen           39.5          17.4               186\n 3 Adelie          Torgersen           40.3          18                 195\n 4 Adelie          Torgersen           NA            NA                  NA\n 5 Adelie          Torgersen           36.7          19.3               193\n 6 Adelie          Torgersen           39.3          20.6               190\n 7 Adelie          Torgersen           38.9          17.8               181\n 8 Adelie          Torgersen           39.2          19.6               195\n 9 Adelie          Torgersen           34.1          18.1               193\n10 Adelie          Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nfilter()e sort()\nPara filtrar dados, usamos o verbo filter() com operadores lógicos (&gt;, ==, etc.) ou funções retornando em valores lógicos (str_detect(), is.na()). A função arrange() classifica os valores de menor para maior ou classifica múltiplas variáveis.\n\npenguins_2 |&gt;\n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Dream\"\n    filter(island == \"Dream\") |&gt; \n    # Classifica os dados pela coluna \"year\"\n    arrange(year)\n\n# A tibble: 124 × 8\n   penguin_species island bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Dream            39.5          16.7               178\n 2 Adelie          Dream            37.2          18.1               178\n 3 Adelie          Dream            39.5          17.8               188\n 4 Adelie          Dream            40.9          18.9               184\n 5 Adelie          Dream            36.4          17                 195\n 6 Adelie          Dream            39.2          21.1               196\n 7 Adelie          Dream            38.8          20                 190\n 8 Adelie          Dream            42.2          18.5               180\n 9 Adelie          Dream            37.6          19.3               181\n10 Adelie          Dream            39.8          19.1               184\n# ℹ 114 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nsummarise()\nComo encontramos a média do tamanho dos bicos dos pinguins na ilha de Biscoe, por espécie de pinguim?\nPara encontrarmos a resposta, devemos filtrar os dados pela ilha Biscoe e então agrupar por espécies. Quando usamos a função summarise(), podemos agrupar os dados para executarmos a redução dos dados.\n\npenguins_2 |&gt; \n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Biscoe\"\n    filter(island == \"Biscoe\") |&gt; \n    # Cálculo da média da coluna \"bill_length_mm\" através da função mean()\n    # O resultado do cálculo será assinalado a nova coluna \"bill_length_mm_mean\"\n    # O segundo parâmetro (na.rm = TRUE) remove os dados não identificados (NAs)\n    # O cálculo é aplicado ao agrupamento de cada espécie, na coluna \"penguin_species\"\n    summarise(\n        bill_length_mm_mean = mean(bill_length_mm, na.rm = TRUE),\n        .by = penguin_species\n    ) |&gt; \n    # Classifica a tabela resultante pelo tamanho do bico\n    arrange(bill_length_mm_mean)\n\n# A tibble: 2 × 2\n  penguin_species bill_length_mm_mean\n  &lt;chr&gt;                         &lt;dbl&gt;\n1 Adelie                         39.0\n2 Gentoo                         47.5\n\n\n\n\nTabelas longas ou largas\nÉ muito comum modificar tabelas nos dois formatos: longas ou largas. Tabelas longas são mais comuns para trabalhar dados, porém muitas vezes os dados que se tem em mãos são estruturados em tabelas largas ou em algumas ocasiões tabelas longas são desejadas.\n\n# Tabela larga\ntidyr::table4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n# Tabela larga para tabela longa\ntable4a_long &lt;- tidyr::table4a |&gt; \n    pivot_longer(\n        cols = !country,\n        names_to = \"year\",\n        values_to = \"cases\"\n    )\n\n# Tabela longa\ntable4a_long\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n# Tabela longa para tabela larga novamente\ntable4a_long |&gt; \n    pivot_wider(\n        names_from = year,\n        values_from = cases\n    )\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nDe fato, o uso de tabelas longas dá origem ao termo tabelas tidy, o modelo de estruturação de dados ideal para data science, e que eventualmente nomeia o tidyverse. Uma tabela é considerada tidy quando:\n\nCada variável é uma coluna\nCada observação é uma linha\nCada valor é uma célula (e cada célula é apenas um valor)\n\nOutros grupos de funções que valem a pena estudar são: separate(), case_when(), complete() e as funções de junção de tabelas. É possível encontrar essas informações no cheat-sheet do dplyr e no cheat-sheet do tidyr."
  },
  {
    "objectID": "blog/blogposts/test/index.html#visualização-de-dados",
    "href": "blog/blogposts/test/index.html#visualização-de-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Visualização de dados",
    "text": "Visualização de dados\nggplot2 é um sistema moderno de visualização de dados extremamente versátil. Diferente do sistema de gráficos do R base, no ggplot2 uma gramática diferente é usada. A gramática dos gráficos (gg) consiste na soma de inúmeros e independentes camadas ou objetos combinados usando o + para construir o gráfico.\nggplot2 diferencia entre dados, o que é demonstrado e como é demonstrado.\n\ndados: os dados a serem utilizados (data.frame ou tibble).\nestética: a função aes() indica as variáveis que correspondem aos axis x,y,z, ou quando é pretendido aplicar parâmetros gráficos (como cores, tamanhos e formatos) conforme o com o gráfico. É possível incluir aes() na função ggplot() ou na função correspondente a uma geometria geom_*.\ngeometria: objetos geom_* indicam qual geometria a ser usada (geom_point(), geom_line(), geom_boxplot(), etc.).\nescalas: objetos do tipo scales_* manipulam axis, definem escala de cores, etc.\nestatísticas: objetos stat_* permitem aplicar transformações estatísticas.\n\n\nGráfico de linha e de disperção\n\n# install.packages(ggthemes)\nlibrary(ggthemes)\n\ntidyr::table1 |&gt; \n    ggplot(aes(year, cases)) +\n    geom_line(aes(color = country), linewidth = 1) +\n    scale_color_colorblind() +\n    scale_x_continuous(breaks = c(1999, 2000)) +\n    labs(\n        title = \"Casos de tuberculose\",\n        subtitle = \"Número de casos de tuberculose no Afeganistão, Brasil e China.\",\n        x = \"\",\n        y = \"\",\n        color = \"País\"\n    )\n\n\n\n\n\n\n\n\n\npenguins |&gt; \n    ggplot(aes(body_mass_g, flipper_length_mm)) +\n    geom_point(aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    scale_color_colorblind() +\n    labs(\n        title = \"Massa corporal e comprimento da nadadeira\",\n        subtitle = \"Dimensões para penguins das espécies Adelie, Chinstrap, e Gentoo\",\n        x = \"Comprimento da nadadeira (mm)\",\n        y = \"Massa corporal (g)\",\n        color = \"Espécies\",\n        shape = \"Espécies\"\n    )\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\npenguins |&gt; \n    ggplot(aes(species, body_mass_g)) +\n    geom_boxplot(aes(fill = species)) +\n    theme_minimal()\n\n\n\n\n\n\n\n\nHá tantas coisas que podemos fazer com o ggplot2 que merece uma postagem somente dedicada a esse pacote. Independente se é necessário contruir um box plot, gráfico de densidade, séries temporais, etc, o ggplot2 tem uma função para isso. Você também pode checar o cheat-sheet do ggplot2]"
  },
  {
    "objectID": "blog/blogposts/test/index.html#aplicar-funções-em-vetores-ou-listas",
    "href": "blog/blogposts/test/index.html#aplicar-funções-em-vetores-ou-listas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Aplicar funções em vetores ou listas",
    "text": "Aplicar funções em vetores ou listas\nO pacote purrr, além de ter o melhor nome de pacote de todos os tempos, é recheado de funções avançadas de programação funcional para vetores e listas. O lapply do R base corresponde ao map() do purrr.\n\n# lista de dois vetores\nlista_vec &lt;- list(x = 1:10, y = 50:70)\n\n# calcula a média para cada\nmap(lista_vec, mean)\n\n$x\n[1] 5.5\n\n$y\n[1] 60\n\n# muda o tipo de output do map_* (dbl, chr, lgl, etc.)\nmap_dbl(lista_vec, mean)\n\n   x    y \n 5.5 60.0 \n\n\nPara mais detalhes e exemplos podem ser encontrados no cheat-sheet do purrr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html",
    "href": "blog/blogposts/introducao-tidyverse/index.html",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "",
    "text": "O tidyverse, uma coleção de pacotes focados em ciência de dados, é um dos principais atrativos da linguagem de programação R. Nesta postagem serão sintetizados os principais aspectos necessários para o início da jornada na ciência de dados com o tidyverse."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#importar-e-salvar-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#importar-e-salvar-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Importar e salvar dados",
    "text": "Importar e salvar dados\nO pacote readr facilita ler ou escrever os mais diversos formatos usando funções que começam com read_* ou write_*. Em comparação ao R base, readr é mais rápido, consegue lidar com nomes de colunas problemáticos e datas são convertidas automaticamente. As tabelas importadas são da classe tibble, do pacote de mesmo nome, tibble, que basicamente é uma versão moderna do data.frame. Na mesma linha, é possível usar a função read_excel() do pacote readxl para importar dados de planilhas de Excel. No exemplo abaixo, importaremos os dados Palmer Penguins, dados de três espécies de pinguim no arquipélago de Palmer, na Antártica.\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nread_csv() ou read_csv2( )\nImporta .CSV (vírgula ou ponto e vírgula)\n\n\nread_delim()\nSeparador geral\n\n\nread_table()\nSeparador de espaços\n\n\n\n\nlibrary(tidyverse)\n\n# Assinala o arquivo penguins.csv, que está na pasta \"data\", ao objeto \"penguins\"\npenguins &lt;- read_csv(\"data/penguins.csv\")\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (6): rowid, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Inspeciona o conteúdo do objeto \"penguins\"\npenguins\n\n# A tibble: 344 × 9\n   rowid species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1     1 Adelie  Torgersen           39.1          18.7               181\n 2     2 Adelie  Torgersen           39.5          17.4               186\n 3     3 Adelie  Torgersen           40.3          18                 195\n 4     4 Adelie  Torgersen           NA            NA                  NA\n 5     5 Adelie  Torgersen           36.7          19.3               193\n 6     6 Adelie  Torgersen           39.3          20.6               190\n 7     7 Adelie  Torgersen           38.9          17.8               181\n 8     8 Adelie  Torgersen           39.2          19.6               195\n 9     9 Adelie  Torgersen           34.1          18.1               193\n10    10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\nPara mais detalhes, vale a pena consultar o cheat-sheet do readr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#trabalhando-com-caracteres",
    "href": "blog/blogposts/introducao-tidyverse/index.html#trabalhando-com-caracteres",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Trabalhando com caracteres",
    "text": "Trabalhando com caracteres\nPara trabalhar com caracteres (strings), usamos o pacote stringr, com suas funções sempre iniciando com str_*, seguido pelo verbo e o primeiro parâmetro. Algumas das funções são:\n\n\n\nFunção\nDescrição\n\n\n\n\nstr_replace()\nSubstitui padrões\n\n\nstr_c()\nCombina caracteres\n\n\nstr_detect()\nDetecta padrões\n\n\nstr_extract()\nExtrai padrões\n\n\nstr_sub()\nExtrai por posição\n\n\nstr_length()\nRetorna o tamanho de uma string\n\n\n\nÉ comum o uso de expressões regulares (regex) para detecção de padrões. Abaixo temos alguns exemplos de funções do stringr em ação em conjunto com o uso de regex.\n\n# Vetor com os nomes dos meses em inglês\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\n\n# substituir 'er' com espaço vazio\nstr_replace(month.name, \"ber$\", \"\")\n\n [1] \"January\"  \"February\" \"March\"    \"April\"    \"May\"      \"June\"    \n [7] \"July\"     \"August\"   \"Septem\"   \"Octo\"     \"Novem\"    \"Decem\"   \n\n\n\n# combinar os caracteres\nstr_c(month.name, 1:12, sep = \"_\")\n\n [1] \"January_1\"   \"February_2\"  \"March_3\"     \"April_4\"     \"May_5\"      \n [6] \"June_6\"      \"July_7\"      \"August_8\"    \"September_9\" \"October_10\" \n[11] \"November_11\" \"December_12\"\n\n\n\n# colapsar combinação\nstr_c(month.name, collapse = \", \")\n\n[1] \"January, February, March, April, May, June, July, August, September, October, November, December\"\n\n\n\n# detectar padrão\nstr_detect(month.name, \"^A\")\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\n\n\n# extrair padrão\nstr_extract(month.name, \"ber$\")\n\n [1] NA    NA    NA    NA    NA    NA    NA    NA    \"ber\" \"ber\" \"ber\" \"ber\"\n\n\n\n# extrair caracteres entre as posições 1 e 2\nstr_sub(month.name, 1, 2)\n\n [1] \"Ja\" \"Fe\" \"Ma\" \"Ap\" \"Ma\" \"Ju\" \"Ju\" \"Au\" \"Se\" \"Oc\" \"No\" \"De\"\n\n\n\n# tamanho da string de cada mês\nstr_length(month.name)\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8\n\n\nMais detalhes sobre as funções e expressões regulares podem ser encontrados no cheat-sheet do stringr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#gerenciamento-de-datas-e-horas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#gerenciamento-de-datas-e-horas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Gerenciamento de datas e horas",
    "text": "Gerenciamento de datas e horas\nO pacote lubridate é excelente para lidar com datas e horas. Apenas devemos conhecer as seguintes abreviações:\n\nymd signfica y:year (ano), m:month (mês), d:day (dia)\nhms signfica h:hour (hora), m:minutes (minutos), s:seconds (segundos)\n\n\n# vetor com datas\ndatas &lt;- c(\"2020/12/31\", \"2012/05/04\", \"2003/09/24\",\"2017/11/24\")\n\n# vetor com datas e horas\ndatas_horas &lt;- c(\"1973-08-11 02:00\", \"2009-06-13 20:00\")\n\ndatas &lt;- ymd(datas)\ndatas\n\n[1] \"2020-12-31\" \"2012-05-04\" \"2003-09-24\" \"2017-11-24\"\n\n\n\ndmy(\"13-08-2002\")\n\n[1] \"2002-08-13\"\n\nymd(\"20020813\")\n\n[1] \"2002-08-13\"\n\n\n\n# extrair o ano\nyear(datas)\n\n[1] 2020 2012 2003 2017\n\n\n\n# extrair o mês\nmonth(datas)\n\n[1] 12  5  9 11\n\n\n\n# extrair o dia da semana\nwday(datas)\n\n[1] 5 6 4 6\n\n\n\n# extrair a hora\nhour(datas_horas)\n\n[1]  2 20\n\n\n\n# adiciona 10 dias\ndatas + days(10)\n\n[1] \"2021-01-10\" \"2012-05-14\" \"2003-10-04\" \"2017-12-04\"\n\n\n\n# adiciona 1 mês\ndatas + month(1)\n\n[1] \"2021-01-01\" \"2012-05-05\" \"2003-09-25\" \"2017-11-25\"\n\n\nPara mais detalhes, veja o cheat-sheet do lubridate."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#transformação-de-tabelas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#transformação-de-tabelas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Transformação de tabelas",
    "text": "Transformação de tabelas\nOs pacotes dplyr e tidyr oferecem gramática para a transformação de dados, ou seja, um conjunto de verbos úteis para resolver problemas. As funções mais importantes são:\n\n\n\nFunção\nDescrição\n\n\n\n\nmutate()\nAdiciona ou modifica variáveis\n\n\nselect()\nSeleciona variábeis\n\n\nfilter()\nAplica filtro\n\n\nsummarise()\nReduz variáveis\n\n\nrename()\nRenomeia colunaas\n\n\n\n\nselect() e rename()\nConseguimos selecionar ou remover colunas com a função select(), usando o nome ou índice da coluna. Para deletar colunas apenas usamos o ponto de exclamação antes do nome ou índice da coluna. A função rename()renomeia colunas da mesma forma, usando o nome ou índice da coluna.\n\n# Assinala o resultado da cadeia ao objeto \"penguins_2\" \npenguins_2 &lt;- penguins |&gt; \n    # Seleciona a coluna \"rowid\".\n    # O ponto de exclamação indica a remoção da coluna \"rowid\"\n    select(!rowid) |&gt; \n    # Renomeia a coluna \"species\" como \"penguin_species\"\n    rename(penguin_species = species)\n\n# Visualizando o novo objeto\npenguins_2\n\n# A tibble: 344 × 8\n   penguin_species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Torgersen           39.1          18.7               181\n 2 Adelie          Torgersen           39.5          17.4               186\n 3 Adelie          Torgersen           40.3          18                 195\n 4 Adelie          Torgersen           NA            NA                  NA\n 5 Adelie          Torgersen           36.7          19.3               193\n 6 Adelie          Torgersen           39.3          20.6               190\n 7 Adelie          Torgersen           38.9          17.8               181\n 8 Adelie          Torgersen           39.2          19.6               195\n 9 Adelie          Torgersen           34.1          18.1               193\n10 Adelie          Torgersen           42            20.2               190\n# ℹ 334 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nfilter()e sort()\nPara filtrar dados, usamos o verbo filter() com operadores lógicos (&gt;, ==, etc.) ou funções retornando em valores lógicos (str_detect(), is.na()). A função arrange() classifica os valores de menor para maior ou classifica múltiplas variáveis.\n\npenguins_2 |&gt;\n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Dream\"\n    filter(island == \"Dream\") |&gt; \n    # Classifica os dados pela coluna \"year\"\n    arrange(year)\n\n# A tibble: 124 × 8\n   penguin_species island bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie          Dream            39.5          16.7               178\n 2 Adelie          Dream            37.2          18.1               178\n 3 Adelie          Dream            39.5          17.8               188\n 4 Adelie          Dream            40.9          18.9               184\n 5 Adelie          Dream            36.4          17                 195\n 6 Adelie          Dream            39.2          21.1               196\n 7 Adelie          Dream            38.8          20                 190\n 8 Adelie          Dream            42.2          18.5               180\n 9 Adelie          Dream            37.6          19.3               181\n10 Adelie          Dream            39.8          19.1               184\n# ℹ 114 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, year &lt;dbl&gt;\n\n\n\n\nsummarise()\nComo encontramos a média do tamanho dos bicos dos pinguins na ilha de Biscoe, por espécie de pinguim?\nPara encontrarmos a resposta, devemos filtrar os dados pela ilha Biscoe e então agrupar por espécies. Quando usamos a função summarise(), podemos agrupar os dados para executarmos a redução dos dados.\n\npenguins_2 |&gt; \n    # Filtra linhas que o conteúdo da coluna \"island\" seja igual a \"Biscoe\"\n    filter(island == \"Biscoe\") |&gt; \n    # Cálculo da média da coluna \"bill_length_mm\" através da função mean()\n    # O resultado do cálculo será assinalado a nova coluna \"bill_length_mm_mean\"\n    # O segundo parâmetro (na.rm = TRUE) remove os dados não identificados (NAs)\n    # O cálculo é aplicado ao agrupamento de cada espécie, na coluna \"penguin_species\"\n    summarise(\n        bill_length_mm_mean = mean(bill_length_mm, na.rm = TRUE),\n        .by = penguin_species\n    ) |&gt; \n    # Classifica a tabela resultante pelo tamanho do bico\n    arrange(bill_length_mm_mean)\n\n# A tibble: 2 × 2\n  penguin_species bill_length_mm_mean\n  &lt;chr&gt;                         &lt;dbl&gt;\n1 Adelie                         39.0\n2 Gentoo                         47.5\n\n\n\n\nTabelas longas ou largas\nÉ muito comum modificar tabelas nos dois formatos: longas ou largas. Tabelas longas são mais comuns para trabalhar dados, porém muitas vezes os dados que se tem em mãos são estruturados em tabelas largas ou em algumas ocasiões tabelas longas são desejadas.\n\n# Tabela larga\ntidyr::table4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n# Tabela larga para tabela longa\ntable4a_long &lt;- tidyr::table4a |&gt; \n    pivot_longer(\n        cols = !country,\n        names_to = \"year\",\n        values_to = \"cases\"\n    )\n\n# Tabela longa\ntable4a_long\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n# Tabela longa para tabela larga novamente\ntable4a_long |&gt; \n    pivot_wider(\n        names_from = year,\n        values_from = cases\n    )\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nDe fato, o uso de tabelas longas dá origem ao termo tabelas tidy, o modelo de estruturação de dados ideal para data science, e que eventualmente nomeia o tidyverse. Uma tabela é considerada tidy quando:\n\nCada variável é uma coluna\nCada observação é uma linha\nCada valor é uma célula (e cada célula é apenas um valor)\n\nOutros grupos de funções que valem a pena estudar são: separate(), case_when(), complete() e as funções de junção de tabelas. É possível encontrar essas informações no cheat-sheet do dplyr e no cheat-sheet do tidyr."
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#visualização-de-dados",
    "href": "blog/blogposts/introducao-tidyverse/index.html#visualização-de-dados",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Visualização de dados",
    "text": "Visualização de dados\nggplot2 é um sistema moderno de visualização de dados extremamente versátil. Diferente do sistema de gráficos do R base, no ggplot2 uma gramática diferente é usada. A gramática dos gráficos (gg) consiste na soma de inúmeros e independentes camadas ou objetos combinados usando o + para construir o gráfico.\nggplot2 diferencia entre dados, o que é demonstrado e como é demonstrado.\n\ndados: os dados a serem utilizados (data.frame ou tibble).\nestética: a função aes() indica as variáveis que correspondem aos axis x,y,z, ou quando é pretendido aplicar parâmetros gráficos (como cores, tamanhos e formatos) conforme o com o gráfico. É possível incluir aes() na função ggplot() ou na função correspondente a uma geometria geom_*.\ngeometria: objetos geom_* indicam qual geometria a ser usada (geom_point(), geom_line(), geom_boxplot(), etc.).\nescalas: objetos do tipo scales_* manipulam axis, definem escala de cores, etc.\nestatísticas: objetos stat_* permitem aplicar transformações estatísticas.\n\n\nGráfico de linha e de disperção\n\n# install.packages(ggthemes)\nlibrary(ggthemes)\n\ntidyr::table1 |&gt; \n    ggplot(aes(year, cases)) +\n    geom_line(aes(color = country), linewidth = 1) +\n    scale_color_colorblind() +\n    scale_x_continuous(breaks = c(1999, 2000)) +\n    labs(\n        title = \"Casos de tuberculose\",\n        subtitle = \"Número de casos de tuberculose no Afeganistão, Brasil e China.\",\n        x = \"\",\n        y = \"\",\n        color = \"País\"\n    )\n\n\n\n\n\n\n\n\n\npenguins |&gt; \n    ggplot(aes(body_mass_g, flipper_length_mm)) +\n    geom_point(aes(color = species, shape = species)) +\n    geom_smooth(method = \"lm\") +\n    scale_color_colorblind() +\n    labs(\n        title = \"Massa corporal e comprimento da nadadeira\",\n        subtitle = \"Dimensões para penguins das espécies Adelie, Chinstrap, e Gentoo\",\n        x = \"Comprimento da nadadeira (mm)\",\n        y = \"Massa corporal (g)\",\n        color = \"Espécies\",\n        shape = \"Espécies\"\n    )\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\npenguins |&gt; \n    ggplot(aes(species, body_mass_g)) +\n    geom_boxplot(aes(fill = species)) +\n    theme_minimal()\n\n\n\n\n\n\n\n\nHá tantas coisas que podemos fazer com o ggplot2 que merece uma postagem somente dedicada a esse pacote. Independente se é necessário contruir um box plot, gráfico de densidade, séries temporais, etc, o ggplot2 tem uma função para isso. Você também pode checar o cheat-sheet do ggplot2]"
  },
  {
    "objectID": "blog/blogposts/introducao-tidyverse/index.html#aplicar-funções-em-vetores-ou-listas",
    "href": "blog/blogposts/introducao-tidyverse/index.html#aplicar-funções-em-vetores-ou-listas",
    "title": "Uma breve introdução ao Tidyverse",
    "section": "Aplicar funções em vetores ou listas",
    "text": "Aplicar funções em vetores ou listas\nO pacote purrr, além de ter o melhor nome de pacote de todos os tempos, é recheado de funções avançadas de programação funcional para vetores e listas. O lapply do R base corresponde ao map() do purrr.\n\n# lista de dois vetores\nlista_vec &lt;- list(x = 1:10, y = 50:70)\n\n# calcula a média para cada\nmap(lista_vec, mean)\n\n$x\n[1] 5.5\n\n$y\n[1] 60\n\n# muda o tipo de output do map_* (dbl, chr, lgl, etc.)\nmap_dbl(lista_vec, mean)\n\n   x    y \n 5.5 60.0 \n\n\nPara mais detalhes e exemplos podem ser encontrados no cheat-sheet do purrr."
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html",
    "href": "blog/blogposts/importacao-excel/index.html",
    "title": "Importação de Planilhas do Excel no R",
    "section": "",
    "text": "Geralmente trabalhamos com diversas fontes de dados. Uma das formas mais comuns em que os dados são armazenados são os arquivos em formato Excel, com as extensões .xls e .xlsx. Nesta postagem vamos explorar as funcionalidades do readxl, um pacote parte do tidyverse que facilita a importação de dados do Excel para o R."
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html#intervalo-de-células",
    "href": "blog/blogposts/importacao-excel/index.html#intervalo-de-células",
    "title": "Importação de Planilhas do Excel no R",
    "section": "Intervalo de células",
    "text": "Intervalo de células\nExitem diversas formas de sinalizar quais células devem ser lidas. É até possível especificar a planilha em específico, se for fornecido um intervalo no estilo do Excel.\n\n# Número máximo de linhas para importar\nread_excel(example_xlsx, n_max = 3)\n\n# A tibble: 3 × 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  \n1          5.1         3.5          1.4         0.2 setosa \n2          4.9         3            1.4         0.2 setosa \n3          4.7         3.2          1.3         0.2 setosa \n\n# Número de linhas para pular\nread_excel(example_xlsx, skip = 3)\n\n# A tibble: 147 × 5\n   `4.7` `3.2` `1.3` `0.2` setosa\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; \n 1   4.6   3.1   1.5   0.2 setosa\n 2   5     3.6   1.4   0.2 setosa\n 3   5.4   3.9   1.7   0.4 setosa\n 4   4.6   3.4   1.4   0.3 setosa\n 5   5     3.4   1.5   0.2 setosa\n 6   4.4   2.9   1.4   0.2 setosa\n 7   4.9   3.1   1.5   0.1 setosa\n 8   5.4   3.7   1.5   0.2 setosa\n 9   4.8   3.4   1.6   0.2 setosa\n10   4.8   3     1.4   0.1 setosa\n# ℹ 137 more rows\n\n# Intervalo de linhas e colunas para importar\nread_excel(example_xlsx, range = \"C1:E4\")\n\n# A tibble: 3 × 3\n  Petal.Length Petal.Width Species\n         &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  \n1          1.4         0.2 setosa \n2          1.4         0.2 setosa \n3          1.3         0.2 setosa \n\n# Intervado de linhas para importar\nread_excel(example_xlsx, range = cell_rows(1:4))\n\n# A tibble: 3 × 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  \n1          5.1         3.5          1.4         0.2 setosa \n2          4.9         3            1.4         0.2 setosa \n3          4.7         3.2          1.3         0.2 setosa \n\n# Intervalo de colunas para importar\nread_excel(example_xlsx, range = cell_cols(\"B:D\"))\n\n# A tibble: 150 × 3\n   Sepal.Width Petal.Length Petal.Width\n         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1         3.5          1.4         0.2\n 2         3            1.4         0.2\n 3         3.2          1.3         0.2\n 4         3.1          1.5         0.2\n 5         3.6          1.4         0.2\n 6         3.9          1.7         0.4\n 7         3.4          1.4         0.3\n 8         3.4          1.5         0.2\n 9         2.9          1.4         0.2\n10         3.1          1.5         0.1\n# ℹ 140 more rows\n\n# Intervalo de linhas e colunas de uma planilha específica\nread_excel(example_xlsx, range = \"mtcars!B1:D5\")\n\n# A tibble: 4 × 3\n    cyl  disp    hp\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     6   160   110\n2     6   160   110\n3     4   108    93\n4     6   258   110"
  },
  {
    "objectID": "blog/blogposts/importacao-excel/index.html#especificação-de-colunas",
    "href": "blog/blogposts/importacao-excel/index.html#especificação-de-colunas",
    "title": "Importação de Planilhas do Excel no R",
    "section": "Especificação de colunas",
    "text": "Especificação de colunas\nEspecificação de colunas é o que define que tipo de dado cada coluna do arquivo Excel será ao ser importado. Por padrão, o read_excel() analisa as primeiras 1000 observações e faz um chute educado sobre qual tipo de dado cada variável possui. É possível aumentar o número de linhas com o parâmetro guess_max.\nPara especificar o tipo de dado de colunas, usamos o parâmetro col_types. Para definir todas as variáveis como, por exemplo, strings, usamos:\n\nread_excel(example_xlsx, col_types = \"text\")\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n   &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;  \n 1 5.1          3.5         1.4          0.2         setosa \n 2 4.9          3           1.4          0.2         setosa \n 3 4.7          3.2         1.3          0.2         setosa \n 4 4.6          3.1         1.5          0.2         setosa \n 5 5            3.6         1.4          0.2         setosa \n 6 5.4          3.9         1.7          0.4         setosa \n 7 4.6          3.4         1.4          0.3         setosa \n 8 5            3.4         1.5          0.2         setosa \n 9 4.4          2.9         1.4          0.2         setosa \n10 4.9          3.1         1.5          0.1         setosa \n# ℹ 140 more rows\n\n\nPara definir cada coluna individualmente, podemos fazer o seguinte:\n\nread_excel(\n    example_xlsx,\n    col_types = c(\"numeric\", \"numeric\", \"guess\", \"guess\", \"text\")\n)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nOs tipos de colunas disponíveis são:\n\nSkip (pula uma coluna)\nGuess (chuta um tipo)\nLogicals (valores lógicos)\nNumeric (numéricos)\nText (texto)\nDate (datas)\nList (listas, para múltiplos tipos de dados)\n\nExemplos:\n\n\n\nlogical\nnumeric\ntext\ndate\nlist\n\n\n\n\nTRUE\n2\nhello\n1999-01-01\nworld\n\n\nFALSE\n3.14\nworld\n2004-02-21\n1"
  }
]